<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VIP Go mu-plugins</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../">
    <link rel="icon" href="images/favicon.ico"/>
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/base.css">
            <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/template.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.css">
            <script src="js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-header phpdocumentor-section">
    <h1 class="phpdocumentor-title"><a href="" class="phpdocumentor-title__link">VIP Go mu-plugins</a><span class="title-separator">/</span>mu-plugins</h1>
    <input class="phpdocumentor-header__menu-button" type="checkbox" id="menu-button" name="menu-button" />
    <label class="phpdocumentor-header__menu-icon" for="menu-button">
        <i class="fas fa-bars"></i>
    </label>
    <section data-search-form class="phpdocumentor-search">
    <label>
        <span class="visually-hidden">Search for</span>
        <svg class="phpdocumentor-search__icon" width="21" height="20" viewBox="0 0 21 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="7.5" cy="7.5" r="6.5" stroke="currentColor" stroke-width="2"/>
            <line x1="12.4892" y1="12.2727" x2="19.1559" y2="18.9393" stroke="currentColor" stroke-width="3"/>
        </svg>
        <input type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading .." disabled />
    </label>
</section>

    <nav class="phpdocumentor-topnav">
    <ul class="phpdocumentor-topnav__menu">
        </ul>
</nav>
</header>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <input class="phpdocumentor-sidebar__menu-button" type="checkbox" id="sidebar-button" name="sidebar-button" />
<label class="phpdocumentor-sidebar__menu-icon" for="sidebar-button">
    Menu
</label>
<aside class="phpdocumentor-column -four phpdocumentor-sidebar">
        
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
                                <h3 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/default.html"><abbr title="\">Global</abbr></a></h3>
                                        <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/automattic.html"><abbr title="\Automattic">Automattic</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/automattic-wp.html"><abbr title="\Automattic\WP">WP</abbr></a></li>
                                            <li><a href="namespaces/automattic-vip.html"><abbr title="\Automattic\VIP">VIP</abbr></a></li>
                                    </ul>
                            <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/tubalmartin.html"><abbr title="\tubalmartin">tubalmartin</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/tubalmartin-cssmin.html"><abbr title="\tubalmartin\CssMin">CssMin</abbr></a></li>
                                    </ul>
                        </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/VIP.html"><abbr title="\VIP">VIP</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/a8c.html"><abbr title="\a8c">a8c</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/a8c-Cron.html"><abbr title="\a8c\Cron">Cron</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/Http.html"><abbr title="\Http">Http</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/Http-Concat.html"><abbr title="\Http\Concat">Concat</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/ES.html"><abbr title="\ES">ES</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/ES-WP.html"><abbr title="\ES\WP">WP</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/wp.html"><abbr title="\wp">wp</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/wp-cli.html"><abbr title="\wp\cli">cli</abbr></a></li>
                            </ul>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="hooks/hooks.html">Hooks</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">class-es-wp-query-wrapper.php</h2>

            <p class="phpdocumentor-summary">ES_WP_Query classes: ES_WP_Query_Wrapper class</p>

    <section class="phpdocumentor-description"></section>






<h3 id="interfaces_class_traits">
    Interfaces, Classes and Traits
    <a href="#interfaces_class_traits" class="headerlink"><i class="fas fa-link"></i></a>
</h3>

<dl class="phpdocumentor-table-of-contents">
    
            <dt class="phpdocumentor-table-of-contents__entry -class"><a href="classes/ES-WP-Query-Wrapper.html"><abbr title="\ES_WP_Query_Wrapper">ES_WP_Query_Wrapper</abbr></a></dt>
        <dd>Elasticsearch replacement for WP_Query</dd>
    
    </dl>





        

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * ES_WP_Query classes: ES_WP_Query_Wrapper class
 *
 * @package ES_WP_Query
 */

/**
 * Elasticsearch replacement for WP_Query
 */
abstract class ES_WP_Query_Wrapper extends WP_Query {

	/**
	 * Mappings between field names and Elasticsearch field keys.
	 *
	 * @access protected
	 * @var array
	 */
	protected $es_map = array();

	/**
	 * Arguments sent to the Elasticsearch server.
	 *
	 * @access public
	 * @var array
	 */
	public $es_args;

	/**
	 * The response from the Elasticsearch server for the query.
	 *
	 * @access public
	 * @var array
	 */
	public $es_response;

	/**
	 * Construct for querying Elasticsearch. Must be implemented in child classes.
	 *
	 * @param array $es_args Arguments to pass to the Elasticsearch server.
	 * @access protected
	 * @return array The response from the Elasticsearch server.
	 */
	abstract protected function query_es( $es_args );

	/**
	 * Override default WP_Query-&gt;is_main_query() to support
	 * this conditional when the main query has been overridden
	 * by this class.
	 *
	 * @fixes #38
	 *
	 * @return bool
	 */
	public function is_main_query() {
		return $this-&gt;get( &#039;es_is_main_query&#039;, false );
	}	

	/**
	 * Maps a field to its Elasticsearch context.
	 *
	 * @param string $field The field to map.
	 * @access public
	 * @return string The mapped field identifier.
	 */
	public function es_map( $field ) {
		if ( ! empty( $this-&gt;es_map[ $field ] ) ) {
			return $this-&gt;es_map[ $field ];
		} else {
			return $field;
		}
	}

	/**
	 * Maps a taxonomy field.
	 *
	 * @param string $taxonomy The taxonomy slug.
	 * @param string $field    The field slug.
	 * @access public
	 * @return string The mapped taxonomy field.
	 */
	public function tax_map( $taxonomy, $field ) {
		if ( &#039;post_tag&#039; === $taxonomy ) {
			$field = str_replace( &#039;term_&#039;, &#039;tag_&#039;, $field );
		} elseif ( &#039;category&#039; === $taxonomy ) {
			$field = str_replace( &#039;term_&#039;, &#039;category_&#039;, $field );
		}
		return sprintf( $this-&gt;es_map( $field ), $taxonomy );
	}

	/**
	 * Maps a meta key by type.
	 *
	 * @param string $meta_key The meta key to map.
	 * @param string $type     The meta type to map.
	 * @access public
	 * @return string The mapped meta key.
	 */
	public function meta_map( $meta_key, $type = &#039;&#039; ) {
		if ( ! empty( $type ) ) {
			return sprintf( $this-&gt;es_map( &#039;post_meta.&#039; . $type ), $meta_key );
		} else {
			return sprintf( $this-&gt;es_map( &#039;post_meta&#039; ), $meta_key );
		}
	}

	/**
	 * Sets the posts based on the Elasticsearch response.
	 *
	 * @param array $q           The query.
	 * @param array $es_response The response from Elasticsearch.
	 * @access protected
	 */
	protected function set_posts( $q, $es_response ) {
		$this-&gt;posts = array();
		if ( isset( $es_response[&#039;hits&#039;][&#039;hits&#039;] ) ) {
			switch ( $q[&#039;fields&#039;] ) {
				case &#039;ids&#039;:
					foreach ( $es_response[&#039;hits&#039;][&#039;hits&#039;] as $hit ) {
						$post_id       = (array) $hit[&#039;_source&#039;][ $this-&gt;es_map( &#039;post_id&#039; ) ];
						$this-&gt;posts[] = reset( $post_id );
					}
					return;

				case &#039;id=&gt;parent&#039;:
					foreach ( $es_response[&#039;hits&#039;][&#039;hits&#039;] as $hit ) {
						$post_id                          = (array) $hit[&#039;_source&#039;][ $this-&gt;es_map( &#039;post_id&#039; ) ];
						$post_parent                      = (array) $hit[&#039;_source&#039;][ $this-&gt;es_map( &#039;post_parent&#039; ) ];
						$this-&gt;posts[ reset( $post_id ) ] = reset( $post_parent );
					}
					return;

				default:
					if ( apply_filters( &#039;es_query_use_source&#039;, false ) ) {
						$this-&gt;posts = wp_list_pluck( $es_response[&#039;hits&#039;][&#039;hits&#039;], &#039;_source&#039; );
						return;
					} else {
						$post_ids = array();
						foreach ( $es_response[&#039;hits&#039;][&#039;hits&#039;] as $hit ) {
							$post_id    = (array) $hit[&#039;_source&#039;][ $this-&gt;es_map( &#039;post_id&#039; ) ];
							$post_ids[] = absint( reset( $post_id ) );
						}
						$post_ids = array_filter( $post_ids );
						if ( ! empty( $post_ids ) ) {
							global $wpdb;
							$post__in    = implode( &#039;,&#039;, $post_ids );
							$this-&gt;posts = $wpdb-&gt;get_results( &quot;SELECT $wpdb-&gt;posts.* FROM $wpdb-&gt;posts WHERE ID IN ($post__in) ORDER BY FIELD( {$wpdb-&gt;posts}.ID, $post__in )&quot; ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.VIP.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.NoCaching, (WordPress.VIP.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.VIP.DirectDatabaseQuery.DirectQuery
						}
						return;
					}
			}
		} else {
			$this-&gt;posts = array();
		}
	}

	/**
	 * Handle no results.
	 *
	 * We&#039;re just going to abandon ship for now, but if it causes issues we&#039;ll
	 * switch to a mysql query where 1=0.
	 *
	 * @todo: Core queries where 1=0 here, which probably happens for good reason.
	 *
	 * @access protected
	 * @return array
	 */
	protected function no_results() {
		$this-&gt;posts         = array();
		$this-&gt;max_num_pages = 0;
		$this-&gt;found_posts   = 0;
		$this-&gt;post_count    = 0;
		return $this-&gt;posts;
	}

	/**
	 * Set up the amount of found posts and the number of pages (if limit clause was used)
	 * for the current query.
	 *
	 * @param array $q           Query variables.
	 * @param array $es_response The response from the Elasticsearch server.
	 * @access public
	 */
	public function set_found_posts( $q, $es_response ) {
		if ( isset( $es_response[&#039;hits&#039;][&#039;total&#039;][&#039;value&#039;] ) ) {
			$this-&gt;found_posts = absint( $es_response[&#039;hits&#039;][&#039;total&#039;][&#039;value&#039;] );
		} elseif ( isset( $es_response[&#039;hits&#039;][&#039;total&#039;] ) ) {
			$this-&gt;found_posts = absint( $es_response[&#039;hits&#039;][&#039;total&#039;] );
		} else {
			$this-&gt;found_posts = 0;
		}
		$this-&gt;found_posts   = apply_filters_ref_array( &#039;es_found_posts&#039;, array( $this-&gt;found_posts, &amp;$this ) );
		$this-&gt;max_num_pages = ceil( $this-&gt;found_posts / $q[&#039;posts_per_page&#039;] );
	}

	/**
	 * Retrieve the posts based on query variables.
	 *
	 * There are a few filters and actions that can be used to modify the post
	 * database query.
	 *
	 * @since 1.5.0
	 * @access public
	 * @uses do_action_ref_array() Calls &#039;pre_get_posts&#039; hook before retrieving posts.
	 *
	 * @todo determine early if the query can be run using ES, otherwise defer to WP_Query
	 *
	 * @return array List of posts.
	 */
	public function get_posts() {
		global $wpdb;

		/**
		 * In addition to what&#039;s below, other fields include:
		 *      post_id
		 *      post_author
		 *          post_author.user_nicename
		 *      post_date
		 *          post_date.year
		 *          post_date.month
		 *          post_date.week
		 *          post_date.day
		 *          post_date.day_of_year
		 *          post_date.day_of_week
		 *          post_date.hour
		 *          post_date.minute
		 *          post_date.second
		 *      post_date_gmt (plus all the same tokens as post_date)
		 *      post_content
		 *          post_content.analyzed
		 *      post_title
		 *          post_title.analyzed
		 *      post_excerpt
		 *      post_status
		 *      ping_status
		 *      post_password
		 *      post_name
		 *      post_modified (plus all the same tokens as post_date)
		 *      post_modified_gmt (plus all the same tokens as post_date)
		 *      post_parent
		 *      menu_order
		 *      post_type
		 *      post_mime_type
		 *      comment_count
		 */
		$this-&gt;es_map = apply_filters(
			&#039;es_field_map&#039;,
			array(
				&#039;post_meta&#039;          =&gt; &#039;post_meta.%s&#039;,
				&#039;post_meta.analyzed&#039; =&gt; &#039;post_meta.%s.analyzed&#039;,
				&#039;post_meta.long&#039;     =&gt; &#039;post_meta.%s.long&#039;,
				&#039;post_meta.double&#039;   =&gt; &#039;post_meta.%s.double&#039;,
				&#039;post_meta.binary&#039;   =&gt; &#039;post_meta.%s.boolean&#039;,
				&#039;post_meta.date&#039;     =&gt; &#039;post_meta.%s.date&#039;,
				&#039;post_meta.datetime&#039; =&gt; &#039;post_meta.%s.datetime&#039;,
				&#039;post_meta.time&#039;     =&gt; &#039;post_meta.%s.time&#039;,
				&#039;post_meta.signed&#039;   =&gt; &#039;post_meta.%s.signed&#039;,
				&#039;post_meta.unsigned&#039; =&gt; &#039;post_meta.%s.unsigned&#039;,
				&#039;term_id&#039;            =&gt; &#039;terms.%s.term_id&#039;,
				&#039;term_slug&#039;          =&gt; &#039;terms.%s.slug&#039;,
				&#039;term_name&#039;          =&gt; &#039;terms.%s.name&#039;,
				&#039;term_tt_id&#039;         =&gt; &#039;terms.%s.term_taxonomy_id&#039;,
				&#039;category_id&#039;        =&gt; &#039;terms.%s.term_id&#039;,
				&#039;category_slug&#039;      =&gt; &#039;terms.%s.slug&#039;,
				&#039;category_name&#039;      =&gt; &#039;terms.%s.name&#039;,
				&#039;category_tt_id&#039;     =&gt; &#039;terms.%s.term_taxonomy_id&#039;,
				&#039;tag_id&#039;             =&gt; &#039;terms.%s.term_id&#039;,
				&#039;tag_slug&#039;           =&gt; &#039;terms.%s.slug&#039;,
				&#039;tag_name&#039;           =&gt; &#039;terms.%s.name&#039;,
				&#039;tag_tt_id&#039;          =&gt; &#039;terms.%s.term_taxonomy_id&#039;,
			)
		);

		$this-&gt;parse_query();

		if ( isset( $this-&gt;query_vars[&#039;es&#039;] ) ) {
			unset( $this-&gt;query_vars[&#039;es&#039;] );
		}

		do_action_ref_array( &#039;pre_get_posts&#039;, array( &amp;$this ) ); // phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedHooknameFound
		do_action_ref_array( &#039;es_pre_get_posts&#039;, array( &amp;$this ) );

		// Shorthand.
		$q = &amp;$this-&gt;query_vars;

		// Fill again in case pre_get_posts unset some vars.
		$q = $this-&gt;fill_query_vars( $q );

		// Parse meta query.
		$this-&gt;meta_query = new ES_WP_Meta_Query();
		$this-&gt;meta_query-&gt;parse_query_vars( $q );

		// Set a flag if a pre_get_posts hook changed the query vars.
		$hash = md5( serialize( $this-&gt;query_vars ) ); // phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.serialize_serialize
		if ( $hash !== $this-&gt;query_vars_hash ) {
			$this-&gt;query_vars_changed = true;
			$this-&gt;query_vars_hash    = $hash;
		}
		unset( $hash );

		// First, let&#039;s clear some variables.
		$distinct = &#039;&#039;;
		$where    = &#039;&#039;;
		$join     = &#039;&#039;;
		$search   = &#039;&#039;;
		$page     = 1;

		// ES.
		$filter = array();
		$query  = array();
		$sort   = array();
		$fields = array();
		$from   = 0;
		$size   = 10;

		if ( ! isset( $q[&#039;ignore_sticky_posts&#039;] ) ) {
			$q[&#039;ignore_sticky_posts&#039;] = false;
		}

		if ( ! isset( $q[&#039;suppress_filters&#039;] ) ) {
			$q[&#039;suppress_filters&#039;] = false;
		}

		if ( ! isset( $q[&#039;cache_results&#039;] ) ) {
			if ( wp_using_ext_object_cache() ) {
				$q[&#039;cache_results&#039;] = false;
			} else {
				$q[&#039;cache_results&#039;] = true;
			}
		}

		if ( ! isset( $q[&#039;update_post_term_cache&#039;] ) ) {
			$q[&#039;update_post_term_cache&#039;] = true;
		}

		if ( ! isset( $q[&#039;update_post_meta_cache&#039;] ) ) {
			$q[&#039;update_post_meta_cache&#039;] = true;
		}

		if ( ! isset( $q[&#039;post_type&#039;] ) ) {
			if ( $this-&gt;is_search ) {
				$q[&#039;post_type&#039;] = &#039;any&#039;;
			} else {
				$q[&#039;post_type&#039;] = &#039;&#039;;
			}
		}
		$post_type = $q[&#039;post_type&#039;];
		if ( ! isset( $q[&#039;posts_per_page&#039;] ) || 0 === intval( $q[&#039;posts_per_page&#039;] ) ) {
			$q[&#039;posts_per_page&#039;] = get_option( &#039;posts_per_page&#039; );
		}
		if ( isset( $q[&#039;showposts&#039;] ) &amp;&amp; $q[&#039;showposts&#039;] ) {
			$q[&#039;showposts&#039;]      = (int) $q[&#039;showposts&#039;];
			$q[&#039;posts_per_page&#039;] = $q[&#039;showposts&#039;];
		}
		if ( ( isset( $q[&#039;posts_per_archive_page&#039;] ) &amp;&amp; 0 !== intval( $q[&#039;posts_per_archive_page&#039;] ) ) &amp;&amp; ( $this-&gt;is_archive || $this-&gt;is_search ) ) {
			$q[&#039;posts_per_page&#039;] = $q[&#039;posts_per_archive_page&#039;];
		}
		if ( ! isset( $q[&#039;nopaging&#039;] ) ) {
			if ( -1 === intval( $q[&#039;posts_per_page&#039;] ) ) {
				$q[&#039;nopaging&#039;] = true; // phpcs:ignore WordPress.VIP.PostsPerPage.posts_per_page_nopaging
			} else {
				$q[&#039;nopaging&#039;] = false;
			}
		}
		if ( $this-&gt;is_feed ) {
			// This overrides posts_per_page.
			if ( ! empty( $q[&#039;posts_per_rss&#039;] ) ) {
				$q[&#039;posts_per_page&#039;] = $q[&#039;posts_per_rss&#039;];
			} else {
				$q[&#039;posts_per_page&#039;] = get_option( &#039;posts_per_rss&#039; );
			}
			$q[&#039;nopaging&#039;] = false;
		}
		$q[&#039;posts_per_page&#039;] = (int) $q[&#039;posts_per_page&#039;];
		if ( $q[&#039;posts_per_page&#039;] &lt; -1 ) {
			$q[&#039;posts_per_page&#039;] = abs( $q[&#039;posts_per_page&#039;] );
		} elseif ( 0 === intval( $q[&#039;posts_per_page&#039;] ) ) {
			$q[&#039;posts_per_page&#039;] = 1;
		}

		if ( ! isset( $q[&#039;comments_per_page&#039;] ) || 0 === intval( $q[&#039;comments_per_page&#039;] ) ) {
			$q[&#039;comments_per_page&#039;] = get_option( &#039;comments_per_page&#039; );
		}

		if ( $this-&gt;is_home &amp;&amp; ( empty( $this-&gt;query ) || &#039;true&#039; === $q[&#039;preview&#039;] ) &amp;&amp; ( &#039;page&#039; === get_option( &#039;show_on_front&#039; ) ) &amp;&amp; get_option( &#039;page_on_front&#039; ) ) {
			$this-&gt;is_page = true;
			$this-&gt;is_home = false;
			$q[&#039;page_id&#039;]  = get_option( &#039;page_on_front&#039; );
		}

		if ( isset( $q[&#039;page&#039;] ) ) {
			$q[&#039;page&#039;] = trim( $q[&#039;page&#039;], &#039;/&#039; );
			$q[&#039;page&#039;] = absint( $q[&#039;page&#039;] );
		}

		switch ( $q[&#039;fields&#039;] ) {
			case &#039;ids&#039;:
				$fields = array( $this-&gt;es_map( &#039;post_id&#039; ) );
				break;
			case &#039;id=&gt;parent&#039;:
				$fields = array( $this-&gt;es_map( &#039;post_id&#039; ), $this-&gt;es_map( &#039;post_parent&#039; ) );
				break;
			default:
				if ( apply_filters( &#039;es_query_use_source&#039;, false ) ) {
					$fields = array( &#039;_source&#039; );
				} else {
					$fields = array( $this-&gt;es_map( &#039;post_id&#039; ) );
				}
		}

		if ( &#039;&#039; !== $q[&#039;menu_order&#039;] ) {
			$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;menu_order&#039; ), $q[&#039;menu_order&#039;] );
		}

		// The &quot;m&quot; parameter is meant for months but accepts datetimes of varying specificity.
		if ( $q[&#039;m&#039;] ) {
			$date  = array( &#039;year&#039; =&gt; substr( $q[&#039;m&#039;], 0, 4 ) );
			$m_len = strlen( $q[&#039;m&#039;] );
			if ( $m_len &gt; 5 ) {
				$date[&#039;month&#039;] = substr( $q[&#039;m&#039;], 4, 2 );
			}
			if ( $m_len &gt; 7 ) {
				$date[&#039;day&#039;] = substr( $q[&#039;m&#039;], 6, 2 );
			}
			if ( $m_len &gt; 9 ) {
				$date[&#039;hour&#039;] = substr( $q[&#039;m&#039;], 8, 2 );
			}
			if ( $m_len &gt; 11 ) {
				$date[&#039;minute&#039;] = substr( $q[&#039;m&#039;], 10, 2 );
			}
			if ( $m_len &gt; 13 ) {
				$date[&#039;second&#039;] = substr( $q[&#039;m&#039;], 12, 2 );
				// If we have absolute precision, we can use a term filter instead of a range.
				$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_date&#039; ), ES_WP_Date_Query::build_datetime( $date ) );
			} else {
				// We don&#039;t have second-level precision, so we need to build a range query from what we have.
				$date_query  = new ES_WP_Date_Query(
					array(
						&#039;after&#039;     =&gt; $date,
						&#039;before&#039;    =&gt; $date,
						&#039;inclusive&#039; =&gt; true,
					)
				);
				$date_filter = $date_query-&gt;get_dsl( $this );
				if ( ! empty( $date_filter ) ) {
					$filter[] = $date_filter;
				} elseif ( false === $date_filter ) {
					// @todo: potentially do this differently; see no_results() for more info
					return $this-&gt;no_results();
				}
			}
		}
		unset( $date_query, $date_filter, $date, $m_len );

		// Handle the other individual date parameters.
		$date_parameters = array();

		if ( &#039;&#039; !== $q[&#039;hour&#039;] ) {
			$date_parameters[&#039;hour&#039;] = $q[&#039;hour&#039;];
		}

		if ( &#039;&#039; !== $q[&#039;minute&#039;] ) {
			$date_parameters[&#039;minute&#039;] = $q[&#039;minute&#039;];
		}

		if ( &#039;&#039; !== $q[&#039;second&#039;] ) {
			$date_parameters[&#039;second&#039;] = $q[&#039;second&#039;];
		}

		if ( $q[&#039;year&#039;] ) {
			$date_parameters[&#039;year&#039;] = $q[&#039;year&#039;];
		}

		if ( $q[&#039;monthnum&#039;] ) {
			$date_parameters[&#039;month&#039;] = $q[&#039;monthnum&#039;];
		}

		if ( $q[&#039;w&#039;] ) {
			$date_parameters[&#039;week&#039;] = $q[&#039;w&#039;];
		}

		if ( $q[&#039;day&#039;] ) {
			$date_parameters[&#039;day&#039;] = $q[&#039;day&#039;];
		}

		if ( $date_parameters ) {
			$date_query  = new ES_WP_Date_Query( array( $date_parameters ) );
			$date_filter = $date_query-&gt;get_dsl( $this );
			if ( ! empty( $date_filter ) ) {
				$filter[] = $date_filter;
			} elseif ( false === $date_filter ) {
				// @todo: potentially do this differently; see no_results() for more info
				return $this-&gt;no_results();
			}
		}
		unset( $date_parameters, $date_query, $date_filter );

		// Handle complex date queries.
		if ( ! empty( $q[&#039;date_query&#039;] ) ) {
			$this-&gt;date_query = new ES_WP_Date_Query( $q[&#039;date_query&#039;] );
			$date_filter      = $this-&gt;date_query-&gt;get_dsl( $this );
			if ( ! empty( $date_filter ) ) {
				$filter[] = $date_filter;
			} elseif ( false === $date_filter ) {
				// @todo: potentially do this differently; see no_results() for more info
				return $this-&gt;no_results();
			}
			unset( $date_filter );
		}


		// If we&#039;ve got a post_type AND it&#039;s not &quot;any&quot; post_type.
		if ( ! empty( $q[&#039;post_type&#039;] ) &amp;&amp; &#039;any&#039; !== $q[&#039;post_type&#039;] ) {
			foreach ( (array) $q[&#039;post_type&#039;] as $_post_type ) {
				$ptype_obj = get_post_type_object( $_post_type );
				if ( ! $ptype_obj || ! $ptype_obj-&gt;query_var || empty( $q[ $ptype_obj-&gt;query_var ] ) ) {
					continue;
				}

				if ( ! $ptype_obj-&gt;hierarchical || strpos( $q[ $ptype_obj-&gt;query_var ], &#039;/&#039; ) === false ) {
					// Non-hierarchical post_types &amp; parent-level-hierarchical post_types can directly use &#039;name&#039;.
					$q[&#039;name&#039;] = $q[ $ptype_obj-&gt;query_var ];
				} else {
					// Hierarchical post_types will operate through this.
					$q[&#039;pagename&#039;] = $q[ $ptype_obj-&gt;query_var ];
					$q[&#039;name&#039;]     = &#039;&#039;;
				}

				// Only one request for a slug is possible, this is why name &amp; pagename are overwritten above.
				break;
			} //end foreach
			unset( $ptype_obj );
		}

		if ( ! empty( $q[&#039;name&#039;] ) ) {
			$q[&#039;name&#039;] = sanitize_title_for_query( $q[&#039;name&#039;] );
			$filter[]  = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_name&#039; ), $q[&#039;name&#039;] );
		} elseif ( ! empty( $q[&#039;pagename&#039;] ) ) {
			if ( isset( $this-&gt;queried_object_id ) ) {
				$reqpage = $this-&gt;queried_object_id;
			} else {
				if ( &#039;page&#039; !== $q[&#039;post_type&#039;] ) {
					foreach ( (array) $q[&#039;post_type&#039;] as $_post_type ) {
						$ptype_obj = get_post_type_object( $_post_type );
						if ( ! $ptype_obj || ! $ptype_obj-&gt;hierarchical ) {
							continue;
						}

						if ( function_exists( &#039;wpcom_vip_get_page_by_path&#039; ) ) {
							$reqpage = wpcom_vip_get_page_by_path( $q[&#039;pagename&#039;], OBJECT, $_post_type );
						} else {
							$reqpage = get_page_by_path( $q[&#039;pagename&#039;], OBJECT, $_post_type ); // phpcs:ignore WordPressVIPMinimum.VIP.RestrictedFunctions.get_page_by_path_get_page_by_path
						}
						if ( $reqpage ) {
							break;
						}
					}
					unset( $ptype_obj );
				} else {
					if ( function_exists( &#039;wpcom_vip_get_page_by_path&#039; ) ) {
						$reqpage = wpcom_vip_get_page_by_path( $q[&#039;pagename&#039;] );
					} else {
						$reqpage = get_page_by_path( $q[&#039;pagename&#039;] ); // phpcs:ignore WordPressVIPMinimum.VIP.RestrictedFunctions.get_page_by_path_get_page_by_path
					}
				}
				if ( ! empty( $reqpage ) ) {
					$reqpage = $reqpage-&gt;ID;
				} else {
					$reqpage = 0;
				}
			}

			$page_for_posts = get_option( &#039;page_for_posts&#039; );
			if ( ( &#039;page&#039; !== get_option( &#039;show_on_front&#039; ) ) || empty( $page_for_posts ) || ( $reqpage !== $page_for_posts ) ) {
				$q[&#039;pagename&#039;] = sanitize_title_for_query( wp_basename( $q[&#039;pagename&#039;] ) );
				$q[&#039;name&#039;]     = $q[&#039;pagename&#039;];
				$filter[]      = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_id&#039; ), absint( $reqpage ) );
				$reqpage_obj   = get_post( $reqpage );
				if ( is_object( $reqpage_obj ) &amp;&amp; &#039;attachment&#039; === $reqpage_obj-&gt;post_type ) {
					$this-&gt;is_attachment = true;
					$q[&#039;post_type&#039;]      = &#039;attachment&#039;;
					$post_type           = $q[&#039;post_type&#039;];
					$this-&gt;is_page       = true;
					$q[&#039;attachment_id&#039;]  = $reqpage;
				}
			}
		} elseif ( ! empty( $q[&#039;attachment&#039;] ) ) {
			$q[&#039;attachment&#039;] = sanitize_title_for_query( wp_basename( $q[&#039;attachment&#039;] ) );
			$q[&#039;name&#039;]       = $q[&#039;attachment&#039;];
			$filter[]        = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_name&#039; ), $q[&#039;attachment&#039;] );
		}


		if ( isset( $q[&#039;comments_popup&#039;] ) &amp;&amp; intval( $q[&#039;comments_popup&#039;] ) ) {
			$q[&#039;p&#039;] = absint( $q[&#039;comments_popup&#039;] );
		}

		// If an attachment is requested by number, let it supersede any post number.
		if ( $q[&#039;attachment_id&#039;] ) {
			$q[&#039;p&#039;] = absint( $q[&#039;attachment_id&#039;] );
		}

		// If a post number is specified, load that post.
		if ( $q[&#039;p&#039;] ) {
			$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_id&#039; ), absint( $q[&#039;p&#039;] ) );
		} elseif ( $q[&#039;post__in&#039;] ) {
			$post__in = array_map( &#039;absint&#039;, $q[&#039;post__in&#039;] );
			$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_id&#039; ), $post__in );
		} elseif ( $q[&#039;post__not_in&#039;] ) { // phpcs:ignore WordPressVIPMinimum.VIP.WPQueryParams.post__not_in
			$post__not_in = array_map( &#039;absint&#039;, $q[&#039;post__not_in&#039;] ); // phpcs:ignore WordPressVIPMinimum.VIP.WPQueryParams.post__not_in
			$filter[]     = array(
				&#039;bool&#039; =&gt; array(
					&#039;must_not&#039; =&gt; $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_id&#039; ), $post__not_in ),
				),
			);
		}

		if ( is_numeric( $q[&#039;post_parent&#039;] ) ) {
			$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_parent&#039; ), absint( $q[&#039;post_parent&#039;] ) );
		} elseif ( $q[&#039;post_parent__in&#039;] ) {
			$post_parent__in = array_map( &#039;absint&#039;, $q[&#039;post_parent__in&#039;] );
			$filter[]        = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_parent&#039; ), $post_parent__in );
		} elseif ( $q[&#039;post_parent__not_in&#039;] ) {
			$post_parent__not_in = array_map( &#039;absint&#039;, $q[&#039;post_parent__not_in&#039;] );
			$filter[]            = array(
				&#039;bool&#039; =&gt; array(
					&#039;must_not&#039; =&gt; $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_parent&#039; ), $post_parent__not_in ),
				),
			);
		}

		if ( $q[&#039;page_id&#039;] ) {
			if ( &#039;page&#039; !== get_option( &#039;show_on_front&#039; ) || intval( get_option( &#039;page_for_posts&#039; ) ) !== intval( $q[&#039;page_id&#039;] ) ) {
				$q[&#039;p&#039;]   = $q[&#039;page_id&#039;];
				$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_id&#039; ), absint( $q[&#039;page_id&#039;] ) );
			}
		}

		// If a search pattern is specified, load the posts that match.
		if ( ! empty( $q[&#039;s&#039;] ) ) {
			$search = $this-&gt;parse_search( $q );
		}

		/**
		 * Filter the search query.
		 *
		 * @param string      $search Search filter for ES query.
		 * @param ES_WP_Query $this   The current ES_WP_Query object.
		 */
		if ( ! empty( $search ) ) {
			$query[&#039;must&#039;] = apply_filters_ref_array( &#039;es_posts_search&#039;, array( $search, &amp;$this ) );
			if ( ! is_user_logged_in() ) {
				$filter[] = array(
					&#039;bool&#039; =&gt; array(
						&#039;should&#039; =&gt; array(
							$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_password&#039; ), &#039;&#039; ),
							$this-&gt;dsl_missing( $this-&gt;es_map( &#039;post_password&#039; ) ),
						),
					),
				);
			}
		}

		// Taxonomies.
		if ( ! $this-&gt;is_singular ) {
			$this-&gt;parse_tax_query( $q );
			$this-&gt;tax_query = ES_WP_Tax_Query::get_from_tax_query( $this-&gt;tax_query );

			$tax_filter = $this-&gt;tax_query-&gt;get_dsl( $this );
			if ( false === $tax_filter ) {
				return $this-&gt;no_results();
			}
			if ( ! empty( $tax_filter ) ) {
				$filter[] = $tax_filter;
			}
			unset( $tax_filter );
		}

		if ( $this-&gt;is_tax ) {
			if ( empty( $post_type ) ) {
				// Do a fully inclusive search for currently registered post types of queried taxonomies.
				$post_type  = array();
				$taxonomies = array_keys( $this-&gt;tax_query-&gt;queried_terms );
				foreach ( get_post_types( array( &#039;exclude_from_search&#039; =&gt; false ) ) as $pt ) {
					$object_taxonomies = &#039;attachment&#039; === $pt ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );
					if ( array_intersect( $taxonomies, $object_taxonomies ) ) {
						$post_type[] = $pt;
					}
				}
				if ( ! $post_type ) {
					$post_type = &#039;any&#039;;
				} elseif ( 1 === count( $post_type ) ) {
					$post_type = $post_type[0];
				}
			}
		}

		/*
		 * Ensure that &#039;taxonomy&#039;, &#039;term&#039;, &#039;term_id&#039;, &#039;cat&#039;, and
		 * &#039;category_name&#039; vars are set for backward compatibility.
		 */
		if ( ! empty( $this-&gt;tax_query-&gt;queried_terms ) ) {
			/*
			 * Set &#039;taxonomy&#039;, &#039;term&#039;, and &#039;term_id&#039; to the
			 * first taxonomy other than &#039;post_tag&#039; or &#039;category&#039;.
			 */
			if ( ! isset( $q[&#039;taxonomy&#039;] ) ) {
				foreach ( $this-&gt;tax_query-&gt;queried_terms as $queried_taxonomy =&gt; $queried_items ) {
					if ( empty( $queried_items[&#039;terms&#039;][0] ) ) {
						continue;
					}

					if ( ! in_array( $queried_taxonomy, array( &#039;category&#039;, &#039;post_tag&#039; ), true ) ) {
						$q[&#039;taxonomy&#039;] = $queried_taxonomy;

						if ( &#039;slug&#039; === $queried_items[&#039;field&#039;] ) {
							$q[&#039;term&#039;] = $queried_items[&#039;terms&#039;][0];
						} else {
							$q[&#039;term_id&#039;] = $queried_items[&#039;terms&#039;][0];
						}
					}
				}
			}

			foreach ( $this-&gt;tax_query-&gt;queried_terms as $queried_taxonomy =&gt; $queried_items ) {
				if ( empty( $queried_items[&#039;terms&#039;][0] ) ) {
					continue;
				}

				if ( &#039;category&#039; === $queried_taxonomy ) {
					$the_cat = get_term_by( $queried_items[&#039;field&#039;], $queried_items[&#039;terms&#039;][0], &#039;category&#039; );
					if ( $the_cat ) {
						$this-&gt;set( &#039;cat&#039;, $the_cat-&gt;term_id );
						$this-&gt;set( &#039;category_name&#039;, $the_cat-&gt;slug );
					}
					unset( $the_cat );
				}

				if ( &#039;post_tag&#039; === $queried_taxonomy ) {
					$the_tag = get_term_by( $queried_items[&#039;field&#039;], $queried_items[&#039;terms&#039;][0], &#039;post_tag&#039; );
					if ( $the_tag ) {
						$this-&gt;set( &#039;tag_id&#039;, $the_tag-&gt;term_id );
					}
					unset( $the_tag );
				}
			}
		}

		/**
		 * Handle this case:
		 *
		 * ! empty( $this-&gt;tax_query-&gt;queries ) || ! empty( $this-&gt;meta_query-&gt;queries )
		 *
		 * @todo Group by post ID.
		 */

		// Author/user stuff.
		if ( ! empty( $q[&#039;author&#039;] ) &amp;&amp; 0 !== intval( $q[&#039;author&#039;] ) ) {
			$q[&#039;author&#039;] = addslashes_gpc( &#039;&#039; . urldecode( $q[&#039;author&#039;] ) );
			$authors     = array_unique( array_map( &#039;intval&#039;, preg_split( &#039;/[,\s]+/&#039;, $q[&#039;author&#039;] ) ) );
			foreach ( $authors as $author ) {
				$key         = $author &gt; 0 ? &#039;author__in&#039; : &#039;author__not_in&#039;;
				$q[ $key ][] = abs( $author );
			}
			$q[&#039;author&#039;] = implode( &#039;,&#039;, $authors );
		}

		if ( ! empty( $q[&#039;author__not_in&#039;] ) ) {
			$author__not_in = array_map( &#039;absint&#039;, array_unique( (array) $q[&#039;author__not_in&#039;] ) );
			$filter[]       = array(
				&#039;bool&#039; =&gt; array(
					&#039;must_not&#039; =&gt; $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author&#039; ), $author__not_in ),
				),
			);
		} elseif ( ! empty( $q[&#039;author__in&#039;] ) ) {
			$author__in = array_map( &#039;absint&#039;, array_unique( (array) $q[&#039;author__in&#039;] ) );
			$filter[]   = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author&#039; ), $author__in );
		}

		// Author stuff for nice URLs.
		if ( &#039;&#039; !== $q[&#039;author_name&#039;] ) {
			if ( strpos( $q[&#039;author_name&#039;], &#039;/&#039; ) !== false ) {
				$q[&#039;author_name&#039;] = explode( &#039;/&#039;, $q[&#039;author_name&#039;] );
				if ( $q[&#039;author_name&#039;][ count( $q[&#039;author_name&#039;] ) - 1 ] ) {
					$q[&#039;author_name&#039;] = $q[&#039;author_name&#039;][ count( $q[&#039;author_name&#039;] ) - 1 ]; // No trailing slash.
				} else {
					$q[&#039;author_name&#039;] = $q[&#039;author_name&#039;][ count( $q[&#039;author_name&#039;] ) - 2 ]; // There was a trailing slash.
				}
			}
			$q[&#039;author_name&#039;] = sanitize_title_for_query( $q[&#039;author_name&#039;] );
			$filter[]         = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author.user_nicename&#039; ), $q[&#039;author_name&#039;] );
		}

		// MIME-Type stuff for attachment browsing.
		if ( isset( $q[&#039;post_mime_type&#039;] ) &amp;&amp; &#039;&#039; !== $q[&#039;post_mime_type&#039;] ) {
			$es_mime = $this-&gt;post_mime_type_query( $q[&#039;post_mime_type&#039;], $wpdb-&gt;posts );
			if ( ! empty( $es_mime[&#039;filters&#039;] ) ) {
				$filter[] = $es_mime[&#039;filters&#039;];
			}
			if ( ! empty( $es_mime[&#039;query&#039;] ) ) {
				if ( empty( $query[&#039;should&#039;] ) ) {
					$query[&#039;should&#039;] = $es_mime[&#039;query&#039;];
				} else {
					$query[&#039;should&#039;] = array_merge( $query[&#039;should&#039;], $es_mime[&#039;query&#039;] );
				}
			}
		}

		if ( ! isset( $q[&#039;order&#039;] ) ) {
			$q[&#039;order&#039;] = &#039;desc&#039;;
		} else {
			$q[&#039;order&#039;] = $this-&gt;parse_order( $q[&#039;order&#039;] );
		}

		// Order by.
		if ( empty( $q[&#039;orderby&#039;] ) ) {
			/*
			 * Boolean false or empty array blanks out ORDER BY,
			 * while leaving the value unset or otherwise empty sets the default.
			 */
			if ( isset( $q[&#039;orderby&#039;] ) &amp;&amp; ( is_array( $q[&#039;orderby&#039;] ) || false === $q[&#039;orderby&#039;] ) ) {
				$orderby = &#039;&#039;;
			} else {
				$sort[] = array( $this-&gt;es_map( &#039;post_date&#039; ) =&gt; $q[&#039;order&#039;] );
			}
		} elseif ( &#039;none&#039; === $q[&#039;orderby&#039;] ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedElseif
			// Nothing to see here.
		} elseif ( &#039;post__in&#039; === $q[&#039;orderby&#039;] &amp;&amp; ! empty( $post__in ) ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedElseif
			// @todo: Figure this out... Elasticsearch doesn&#039;t have an equivalent of this
			// $orderby = &quot;FIELD( {$wpdb-&gt;posts}.ID, $post__in )&quot;;.
		} elseif ( &#039;post_parent__in&#039; === $q[&#039;orderby&#039;] &amp;&amp; ! empty( $post_parent__in ) ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedElseif
			// See above.
			// $orderby = &quot;FIELD( {$wpdb-&gt;posts}.post_parent, $post_parent__in )&quot;;.
		} else {
			if ( is_array( $q[&#039;orderby&#039;] ) ) {
				foreach ( $q[&#039;orderby&#039;] as $_orderby =&gt; $order ) {
					$orderby = addslashes_gpc( urldecode( $_orderby ) );
					$parsed  = $this-&gt;parse_orderby( $orderby );

					if ( ! $parsed ) {
						continue;
					}

					$sort[] = array( $parsed =&gt; $this-&gt;parse_order( $order ) );
				}
			} else {
				$q[&#039;orderby&#039;] = urldecode( $q[&#039;orderby&#039;] );
				$q[&#039;orderby&#039;] = addslashes_gpc( $q[&#039;orderby&#039;] );

				foreach ( explode( &#039; &#039;, $q[&#039;orderby&#039;] ) as $i =&gt; $orderby ) {
					$parsed = $this-&gt;parse_orderby( $orderby );
					// Only allow certain values for safety.
					if ( ! $parsed ) {
						continue;
					}

					$sort[] = array( $parsed =&gt; $q[&#039;order&#039;] );
				}

				if ( empty( $sort ) ) {
					$sort[] = array( $this-&gt;es_map( &#039;post_date&#039; ) =&gt; $q[&#039;order&#039;] );
				}
			}
		}

		// Order search results by relevance only when another &quot;orderby&quot; is not specified in the query.
		if ( ! empty( $q[&#039;s&#039;] ) ) {
			$search_orderby = array();
			if ( ( empty( $q[&#039;orderby&#039;] ) &amp;&amp; ! $this-&gt;is_feed ) || ( isset( $q[&#039;orderby&#039;] ) &amp;&amp; &#039;relevance&#039; === $q[&#039;orderby&#039;] ) ) {
				$search_orderby = array( &#039;_score&#039; );
			}

			/**
			 * Filter the order used when ordering search results.
			 *
			 * @param array       $search_orderby The order clause.
			 * @param ES_WP_Query $this           The current ES_WP_Query instance.
			 */
			$search_orderby = apply_filters( &#039;es_posts_search_orderby&#039;, $search_orderby, $this );
			if ( $search_orderby ) {
				$sort = $sort ? array_merge( $search_orderby, $sort ) : $search_orderby;
			}
		}

		if ( is_array( $post_type ) &amp;&amp; count( $post_type ) &gt; 1 ) {
			$post_type_cap = &#039;multiple_post_type&#039;;
		} else {
			if ( is_array( $post_type ) ) {
				$post_type = reset( $post_type );
			}
			$post_type_object = get_post_type_object( $post_type );
			if ( empty( $post_type_object ) ) {
				$post_type_cap = $post_type;
			}
		}

		if ( &#039;any&#039; === $post_type ) {
			$in_search_post_types = get_post_types( array( &#039;exclude_from_search&#039; =&gt; false ) );
			if ( empty( $in_search_post_types ) ) {
				// @todo: potentially do this differently; see no_results() for more info
				return $this-&gt;no_results();
			} else {
				$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_type&#039; ), array_values( $in_search_post_types ) );
			}
		} elseif ( ! empty( $post_type ) ) {
			$filter[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_type&#039; ), array_values( (array) $post_type ) );
			if ( ! is_array( $post_type ) ) {
				$post_type_object = get_post_type_object( $post_type );
			}
		} elseif ( $this-&gt;is_attachment ) {
			$filter[]         = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_type&#039; ), &#039;attachment&#039; );
			$post_type_object = get_post_type_object( &#039;attachment&#039; );
		} elseif ( $this-&gt;is_page ) {
			$filter[]         = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_type&#039; ), &#039;page&#039; );
			$post_type_object = get_post_type_object( &#039;page&#039; );
		} else {
			$filter[]         = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_type&#039; ), &#039;post&#039; );
			$post_type_object = get_post_type_object( &#039;post&#039; );
		}

		$edit_cap = &#039;edit_post&#039;;
		$read_cap = &#039;read_post&#039;;

		if ( ! empty( $post_type_object ) ) {
			$edit_others_cap  = $post_type_object-&gt;cap-&gt;edit_others_posts;
			$read_private_cap = $post_type_object-&gt;cap-&gt;read_private_posts;
		} else {
			$edit_others_cap  = &#039;edit_others_&#039; . $post_type_cap . &#039;s&#039;;
			$read_private_cap = &#039;read_private_&#039; . $post_type_cap . &#039;s&#039;;
		}

		$user_id = get_current_user_id();

		if ( ! empty( $q[&#039;post_status&#039;] ) ) {
			$status_ands = array();
			$q_status    = $q[&#039;post_status&#039;];
			if ( ! is_array( $q_status ) ) {
				$q_status = explode( &#039;,&#039;, $q_status );
			}
			$r_status = array();
			$p_status = array();
			$e_status = array();
			if ( in_array( &#039;any&#039;, $q_status, true ) ) {
				$e_status = get_post_stati( array( &#039;exclude_from_search&#039; =&gt; true ) );
				$e_status = array_values( $e_status );
			} else {
				foreach ( get_post_stati() as $status ) {
					if ( in_array( $status, $q_status, true ) ) {
						if ( &#039;private&#039; === $status ) {
							$p_status[] = $status;
						} else {
							$r_status[] = $status;
						}
					}
				}
			}

			if ( empty( $q[&#039;perm&#039;] ) || &#039;readable&#039; !== $q[&#039;perm&#039;] ) {
				$r_status = array_merge( $r_status, $p_status );
				unset( $p_status );
			}

			if ( ! empty( $e_status ) ) {
				$status_ands[] = array(
					&#039;bool&#039; =&gt; array(
						&#039;must_not&#039; =&gt; $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $e_status ),
					),
				);
			}
			if ( ! empty( $r_status ) ) {
				if ( ! empty( $q[&#039;perm&#039;] ) &amp;&amp; &#039;editable&#039; === $q[&#039;perm&#039;] &amp;&amp; ! current_user_can( $edit_others_cap ) ) {
					$status_ands[] = array(
						&#039;bool&#039; =&gt; array(
							&#039;filter&#039; =&gt; array(
								$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author&#039; ), $user_id ),
								$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $r_status ),
							),
						),
					);
				} else {
					$status_ands[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $r_status );
				}
			}
			if ( ! empty( $p_status ) ) {
				if ( ! empty( $q[&#039;perm&#039;] ) &amp;&amp; &#039;readable&#039; === $q[&#039;perm&#039;] &amp;&amp; ! current_user_can( $read_private_cap ) ) {
					$status_ands[] = array(
						&#039;bool&#039; =&gt; array(
							&#039;filter&#039; =&gt; array(
								$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author&#039; ), $user_id ),
								$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $p_status ),
							),
						),
					);
				} else {
					$status_ands[] = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $p_status );
				}
			}
			$filter = array_merge( $filter, $status_ands );
		} elseif ( ! $this-&gt;is_singular ) {
			$singular_states = array( &#039;publish&#039; );

			// Add public states.
			$singular_states = array_merge( $singular_states, (array) get_post_stati( array( &#039;public&#039; =&gt; true ) ) );

			if ( $this-&gt;is_admin ) {
				// Add protected states that should show in the admin all list.
				$singular_states = array_merge(
					$singular_states,
					(array) get_post_stati(
						array(
							&#039;protected&#039;              =&gt; true,
							&#039;show_in_admin_all_list&#039; =&gt; true,
						)
					)
				);
			}

			if ( is_user_logged_in() ) {
				// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.
				$private_states      = get_post_stati( array( &#039;private&#039; =&gt; true ) );
				$singular_states_ors = array();
				foreach ( (array) $private_states as $state ) {
					// @todo: leaving off here
					if ( current_user_can( $read_private_cap ) ) {
						$singular_states[] = $state;
					} else {
						$singular_states_ors[] = array(
							&#039;bool&#039; =&gt; array(
								&#039;filter&#039; =&gt; array(
									$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_author&#039; ), $user_id ),
									$this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $state ),
								),
							),
						);
					}
				}
			}

			$singular_states        = array_values( array_unique( $singular_states ) );
			$singular_states_filter = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_status&#039; ), $singular_states );
			if ( ! empty( $singular_states_ors ) ) {
				$singular_states_ors[] = $singular_states_filter;
				$filter[]              = array(
					&#039;bool&#039; =&gt; array(
						&#039;should&#039; =&gt; $singular_states_ors,
					),
				);
			} else {
				$filter[] = $singular_states_filter;
			}
			unset( $singular_states, $singular_states_filter, $singular_states_ors, $private_states );
		}

		if ( ! empty( $this-&gt;meta_query-&gt;queries ) ) {
			$filter[] = $this-&gt;meta_query-&gt;get_dsl( $this, &#039;post&#039; );
		}

		// Apply filters on the filter clause prior to paging so that any
		// manipulations to them are reflected in the paging by day queries.
		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$filter = apply_filters_ref_array( &#039;es_query_filter&#039;, array( $filter, &amp;$this ) );
		}

		// Paging.
		if ( empty( $q[&#039;nopaging&#039;] ) &amp;&amp; ! $this-&gt;is_singular ) {
			$page = absint( $q[&#039;paged&#039;] );
			if ( ! $page ) {
				$page = 1;
			}

			if ( empty( $q[&#039;offset&#039;] ) ) {
				$from = ( $page - 1 ) * $q[&#039;posts_per_page&#039;];
			} else { // we&#039;re ignoring $page and using &#039;offset&#039;.
				$from = absint( $q[&#039;offset&#039;] );
			}
			$size = $q[&#039;posts_per_page&#039;];
		} else {
			$size = false;
			$from = $size;
		}

		// Comments feeds.
		// @todo: come back to this.
		if ( 0 &amp;&amp; $this-&gt;is_comment_feed &amp;&amp; ( $this-&gt;is_archive || $this-&gt;is_search || ! $this-&gt;is_singular ) ) {
			if ( $this-&gt;is_archive || $this-&gt;is_search ) {
				$cjoin    = &quot;JOIN $wpdb-&gt;posts ON ($wpdb-&gt;comments.comment_post_ID = $wpdb-&gt;posts.ID) $join &quot;;
				$cwhere   = &quot;WHERE comment_approved = &#039;1&#039; $where&quot;;
				$cgroupby = &quot;$wpdb-&gt;comments.comment_id&quot;;
			} else { // Other non singular e.g. front.
				$cjoin    = &quot;JOIN $wpdb-&gt;posts ON ( $wpdb-&gt;comments.comment_post_ID = $wpdb-&gt;posts.ID )&quot;;
				$cwhere   = &quot;WHERE post_status = &#039;publish&#039; AND comment_approved = &#039;1&#039;&quot;;
				$cgroupby = &#039;&#039;;
			}

			if ( ! $q[&#039;suppress_filters&#039;] ) {
				$cjoin    = apply_filters_ref_array( &#039;es_comment_feed_join&#039;, array( $cjoin, &amp;$this ) );
				$cwhere   = apply_filters_ref_array( &#039;es_comment_feed_where&#039;, array( $cwhere, &amp;$this ) );
				$cgroupby = apply_filters_ref_array( &#039;es_comment_feed_groupby&#039;, array( $cgroupby, &amp;$this ) );
				$corderby = apply_filters_ref_array( &#039;es_comment_feed_orderby&#039;, array( &#039;comment_date_gmt DESC&#039;, &amp;$this ) );
				$climits  = apply_filters_ref_array( &#039;es_comment_feed_limits&#039;, array( &#039;LIMIT &#039; . get_option( &#039;posts_per_rss&#039; ), &amp;$this ) );
			}
			$cgroupby = ( ! empty( $cgroupby ) ) ? &#039;GROUP BY &#039; . $cgroupby : &#039;&#039;;
			$corderby = ( ! empty( $corderby ) ) ? &#039;ORDER BY &#039; . $corderby : &#039;&#039;;

			$this-&gt;comments      = (array) $wpdb-&gt;get_results( &quot;SELECT $distinct $wpdb-&gt;comments.* FROM $wpdb-&gt;comments $cjoin $cwhere $cgroupby $corderby $climits&quot; ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.VIP.DirectDatabaseQuery.NoCaching, WordPress.VIP.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.DirectQuery
			$this-&gt;comment_count = count( $this-&gt;comments );

			$post_ids = array();

			foreach ( $this-&gt;comments as $comment ) {
				$post_ids[] = (int) $comment-&gt;comment_post_ID;
			}

			$post_ids = join( &#039;,&#039;, $post_ids );
			$join     = &#039;&#039;;
			if ( $post_ids ) {
				$where = &quot;AND $wpdb-&gt;posts.ID IN ($post_ids) &quot;;
			} else {
				$where = &#039;AND 0&#039;;
			}
		}

		// Run cleanup on our filter and query.
		$filter = array_filter( $filter );

		$query = array_filter( $query );
		if ( ! empty( $query ) ) {
			if (
				1 === count( $query )
				&amp;&amp; ! empty( $query[&#039;must&#039;] )
				&amp;&amp; 1 === count( $query[&#039;must&#039;] )
				&amp;&amp; empty( $filter )
			) {
				$query = $query[&#039;must&#039;];
			} else {
				$query = array(
					&#039;bool&#039; =&gt; $query,
				);
			}
		}

		$pieces = array( &#039;filter&#039;, &#039;query&#039;, &#039;sort&#039;, &#039;fields&#039;, &#039;size&#039;, &#039;from&#039; );

		// Apply post-paging filters on our clauses. Only plugins that
		// manipulate paging queries should use these hooks.
		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$filter = apply_filters_ref_array( &#039;es_posts_filter_paged&#039;, array( $filter, &amp;$this ) );
			$query  = apply_filters_ref_array( &#039;es_posts_query_paged&#039;, array( $query, &amp;$this ) );
			$sort   = apply_filters_ref_array( &#039;es_posts_sort&#039;, array( $sort, &amp;$this ) );
			$fields = apply_filters_ref_array( &#039;es_posts_fields&#039;, array( $fields, &amp;$this ) );
			$size   = apply_filters_ref_array( &#039;es_posts_size&#039;, array( $size, &amp;$this ) );
			$from   = apply_filters_ref_array( &#039;es_posts_from&#039;, array( $from, &amp;$this ) );

			// Filter all clauses at once, for convenience.
			$clauses = (array) apply_filters_ref_array( &#039;es_posts_clauses&#039;, array( compact( $pieces ), &amp;$this ) );
			foreach ( $pieces as $piece ) {
				$$piece = isset( $clauses[ $piece ] ) ? $clauses[ $piece ] : &#039;&#039;; // phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedVariableFound
			}
		}

		// Announce current selection parameters. For use by caching plugins.
		do_action(
			&#039;es_posts_selection&#039;,
			array(
				&#039;filter&#039; =&gt; $filter,
				&#039;query&#039;  =&gt; $query,
				&#039;sort&#039;   =&gt; $sort,
				&#039;fields&#039; =&gt; $fields,
				&#039;size&#039;   =&gt; $size,
				&#039;from&#039;   =&gt; $from,
			)
		);

		// Filter again for the benefit of caching plugins. Regular plugins should use the hooks above.
		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$filter = apply_filters_ref_array( &#039;es_posts_filter_request&#039;, array( $filter, &amp;$this ) );
			$query  = apply_filters_ref_array( &#039;es_posts_query_request&#039;, array( $query, &amp;$this ) );
			$sort   = apply_filters_ref_array( &#039;es_posts_sort_request&#039;, array( $sort, &amp;$this ) );
			$fields = apply_filters_ref_array( &#039;es_posts_fields_request&#039;, array( $fields, &amp;$this ) );
			$size   = apply_filters_ref_array( &#039;es_posts_size_request&#039;, array( $size, &amp;$this ) );
			$from   = apply_filters_ref_array( &#039;es_posts_from_request&#039;, array( $from, &amp;$this ) );

			// Filter all clauses at once, for convenience.
			$clauses = (array) apply_filters_ref_array( &#039;es_posts_clauses_request&#039;, array( compact( $pieces ), &amp;$this ) );
			foreach ( $pieces as $piece ) {
				$$piece = isset( $clauses[ $piece ] ) ? $clauses[ $piece ] : &#039;&#039;; // phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedVariableFound
			}
		}

		// Add the filters to the query.
		if ( ! empty( $filter ) ) {
			if ( empty( $query[&#039;bool&#039;][&#039;filter&#039;] ) ) {
				$query[&#039;bool&#039;][&#039;filter&#039;] = array();
			}
			$query[&#039;bool&#039;][&#039;filter&#039;] = array_merge( $query[&#039;bool&#039;][&#039;filter&#039;], $filter );
		}

		$this-&gt;es_args = array(
			&#039;query&#039;   =&gt; $query,
			&#039;sort&#039;    =&gt; $sort,
			&#039;_source&#039; =&gt; $fields,
			&#039;from&#039;    =&gt; $from,
			&#039;size&#039;    =&gt; $size,
		);

		// Remove empty criteria.
		foreach ( $this-&gt;es_args as $key =&gt; $value ) {
			if ( empty( $value ) &amp;&amp; 0 !== $value ) {
				unset( $this-&gt;es_args[ $key ] );
			}
		}

		// Elasticsearch needs a size, so we set it very high if posts_per_page = -1.
		if ( -1 === $q[&#039;posts_per_page&#039;] &amp;&amp; ! isset( $this-&gt;es_args[&#039;size&#039;] ) ) {
			$size                  = apply_filters( &#039;es_query_max_results&#039;, 1000 );
			$this-&gt;es_args[&#039;size&#039;] = $size;
		}
		
		// ES &gt; 7.0 doesn&#039;t return the actual total hits by default (capped at 10k), but we need accurate counts
		$this-&gt;es_args[ &#039;track_total_hits&#039; ] = true;

		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$this-&gt;es_args = apply_filters_ref_array( &#039;es_posts_request&#039;, array( $this-&gt;es_args, &amp;$this ) );
		}

		if ( &#039;ids&#039; === $q[&#039;fields&#039;] || &#039;id=&gt;parent&#039; === $q[&#039;fields&#039;] || apply_filters( &#039;es_query_use_source&#039;, false ) ) {
			$this-&gt;es_response = $this-&gt;query_es( $this-&gt;es_args );
			$this-&gt;set_posts( $q, $this-&gt;es_response );
			$this-&gt;post_count = count( $this-&gt;posts );
			$this-&gt;set_found_posts( $q, $this-&gt;es_response );

			return $this-&gt;posts;
		}

		$this-&gt;es_response = $this-&gt;query_es( $this-&gt;es_args );
		$this-&gt;set_posts( $q, $this-&gt;es_response );
		$this-&gt;set_found_posts( $q, $this-&gt;es_response );

		// The rest of this method is mostly core.
		// Convert to WP_Post objects.
		if ( $this-&gt;posts ) {
			$this-&gt;posts = array_map( &#039;get_post&#039;, $this-&gt;posts );
		}

		// Raw results filter. Prior to status checks.
		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$this-&gt;posts = apply_filters_ref_array( &#039;es_posts_results&#039;, array( $this-&gt;posts, &amp;$this ) );
		}

		// @todo: address this
		if ( 0 &amp;&amp; ! empty( $this-&gt;posts ) &amp;&amp; $this-&gt;is_comment_feed &amp;&amp; $this-&gt;is_singular ) {
			$cjoin               = apply_filters_ref_array( &#039;es_comment_feed_join&#039;, array( &#039;&#039;, &amp;$this ) );
			$cwhere              = apply_filters_ref_array( &#039;es_comment_feed_where&#039;, array( &quot;WHERE comment_post_ID = &#039;{$this-&gt;posts[0]-&gt;ID}&#039; AND comment_approved = &#039;1&#039;&quot;, &amp;$this ) );
			$cgroupby            = apply_filters_ref_array( &#039;es_comment_feed_groupby&#039;, array( &#039;&#039;, &amp;$this ) );
			$cgroupby            = ( ! empty( $cgroupby ) ) ? &#039;GROUP BY &#039; . $cgroupby : &#039;&#039;;
			$corderby            = apply_filters_ref_array( &#039;es_comment_feed_orderby&#039;, array( &#039;comment_date_gmt DESC&#039;, &amp;$this ) );
			$corderby            = ( ! empty( $corderby ) ) ? &#039;ORDER BY &#039; . $corderby : &#039;&#039;;
			$climits             = apply_filters_ref_array( &#039;es_comment_feed_limits&#039;, array( &#039;LIMIT &#039; . get_option( &#039;posts_per_rss&#039; ), &amp;$this ) );
			$comments_request    = &quot;SELECT $wpdb-&gt;comments.* FROM $wpdb-&gt;comments $cjoin $cwhere $cgroupby $corderby $climits&quot;;
			$this-&gt;comments      = $wpdb-&gt;get_results( $comments_request ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.VIP.DirectDatabaseQuery.NoCaching, WordPress.VIP.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.DirectQuery
			$this-&gt;comment_count = count( $this-&gt;comments );
		}

		// Check post status to determine if post should be displayed.
		if ( ! empty( $this-&gt;posts ) &amp;&amp; ( $this-&gt;is_single || $this-&gt;is_page ) ) {
			$status          = get_post_status( $this-&gt;posts[0] );
			$post_status_obj = get_post_status_object( $status );
			if ( ! $post_status_obj-&gt;public ) {
				if ( ! is_user_logged_in() ) {
					// User must be logged in to view unpublished posts.
					$this-&gt;posts = array();
				} else {
					if ( $post_status_obj-&gt;protected ) {
						// User must have edit permissions on the draft to preview.
						if ( ! current_user_can( $edit_cap, $this-&gt;posts[0]-&gt;ID ) ) {
							$this-&gt;posts = array();
						} else {
							$this-&gt;is_preview = true;
							if ( &#039;future&#039; !== $status ) {
								$this-&gt;posts[0]-&gt;post_date = current_time( &#039;mysql&#039; );
							}
						}
					} elseif ( $post_status_obj-&gt;private ) {
						if ( ! current_user_can( $read_cap, $this-&gt;posts[0]-&gt;ID ) ) {
							$this-&gt;posts = array();
						}
					} else {
						$this-&gt;posts = array();
					}
				}
			}

			if ( $this-&gt;is_preview &amp;&amp; $this-&gt;posts &amp;&amp; current_user_can( $edit_cap, $this-&gt;posts[0]-&gt;ID ) ) {
				$this-&gt;posts[0] = get_post( apply_filters_ref_array( &#039;es_the_preview&#039;, array( $this-&gt;posts[0], &amp;$this ) ) );
			}
		}

		// @todo: address this
		// Put sticky posts at the top of the posts array
		$sticky_posts = get_option( &#039;sticky_posts&#039; );
		if ( 0 &amp;&amp; $this-&gt;is_home &amp;&amp; $page &lt;= 1 &amp;&amp; is_array( $sticky_posts ) &amp;&amp; ! empty( $sticky_posts ) &amp;&amp; ! $q[&#039;ignore_sticky_posts&#039;] ) {
			$num_posts     = count( $this-&gt;posts );
			$sticky_offset = 0;
			// Loop over posts and relocate stickies to the front.
			for ( $i = 0; $i &lt; $num_posts; $i++ ) {
				if ( in_array( $this-&gt;posts[ $i ]-&gt;ID, $sticky_posts, true ) ) {
					$sticky_post = $this-&gt;posts[ $i ];
					// Remove sticky from current position.
					array_splice( $this-&gt;posts, $i, 1 );
					// Move to front, after other stickies.
					array_splice( $this-&gt;posts, $sticky_offset, 0, array( $sticky_post ) );
					// Increment the sticky offset. The next sticky will be placed at this offset.
					$sticky_offset++;
					// Remove post from sticky posts array.
					$offset = array_search( $sticky_post-&gt;ID, $sticky_posts, true );
					unset( $sticky_posts[ $offset ] );
				}
			}

			// If any posts have been excluded specifically, Ignore those that are sticky.
			if ( ! empty( $sticky_posts ) &amp;&amp; ! empty( $q[&#039;post__not_in&#039;] ) ) { // phpcs:ignore WordPressVIPMinimum.VIP.WPQueryParams.post__not_in
				$sticky_posts = array_diff( $sticky_posts, $q[&#039;post__not_in&#039;] ); // phpcs:ignore WordPressVIPMinimum.VIP.WPQueryParams.post__not_in
			}

			// Fetch sticky posts that weren&#039;t in the query results.
			if ( ! empty( $sticky_posts ) ) {
				$stickies = get_posts( // phpcs:ignore WordPressVIPMinimum.VIP.RestrictedFunctions.get_posts_get_posts
					array(
						&#039;post__in&#039;    =&gt; $sticky_posts,
						&#039;post_type&#039;   =&gt; $post_type,
						&#039;post_status&#039; =&gt; &#039;publish&#039;,
						&#039;nopaging&#039;    =&gt; true, // phpcs:ignore WordPress.VIP.PostsPerPage.posts_per_page_nopaging
					)
				);

				foreach ( $stickies as $sticky_post ) {
					array_splice( $this-&gt;posts, $sticky_offset, 0, array( $sticky_post ) );
					$sticky_offset++;
				}
			}
		}

		if ( ! $q[&#039;suppress_filters&#039;] ) {
			$this-&gt;posts = apply_filters_ref_array( &#039;es_the_posts&#039;, array( $this-&gt;posts, &amp;$this ) );
		}

		// Ensure that any posts added/modified via one of the filters above are
		// of the type WP_Post and are filtered.
		if ( $this-&gt;posts ) {
			$this-&gt;post_count = count( $this-&gt;posts );

			$this-&gt;posts = array_map( &#039;get_post&#039;, $this-&gt;posts );

			if ( $q[&#039;cache_results&#039;] ) {
				update_post_caches( $this-&gt;posts, $post_type, $q[&#039;update_post_term_cache&#039;], $q[&#039;update_post_meta_cache&#039;] );
			}

			$this-&gt;post = reset( $this-&gt;posts );
		} else {
			$this-&gt;post_count = 0;
			$this-&gt;posts      = array();
		}

		return $this-&gt;posts;
	}


	/**
	 * Generate DSL for the WHERE clause based on passed search terms.
	 *
	 * @since 3.7.0
	 *
	 * @param array $q Query variables.
	 * @return array DSL for the WHERE clause.
	 */
	protected function parse_search( &amp;$q ) {
		// Added slashes screw with quote grouping when done early, so done later.
		$q[&#039;s&#039;] = stripslashes( $q[&#039;s&#039;] );
		if ( empty( $_GET[&#039;s&#039;] ) &amp;&amp; $this-&gt;is_main_query() ) { // phpcs:ignore WordPress.VIP.SuperGlobalInputUsage.AccessDetected, WordPress.Security.NonceVerification.NoNonceVerification
			$q[&#039;s&#039;] = urldecode( $q[&#039;s&#039;] );
		}
		// There are no line breaks in &lt;input /&gt; fields.
		$q[&#039;s&#039;] = str_replace( array( &quot;\r&quot;, &quot;\n&quot; ), &#039;&#039;, $q[&#039;s&#039;] );

		// @todo: add a wildcard match here, I guess...
		// $n = ! empty( $q[&#039;exact&#039;] ) ? &#039;&#039; : &#039;%&#039;; phpcs:ignore Squiz.PHP.CommentedOutCode.Found
		$fields = array( $this-&gt;es_map( &#039;post_title.analyzed&#039; ) . &#039;^3&#039;, $this-&gt;es_map( &#039;post_content.analyzed&#039; ) );

		/**
		 * Filter the searchable fields. Defaults to (the mapped forms of)
		 * post_title and post_content to match core as closely as possible.
		 *
		 * The fields passed are mapped for the ES adapter, and it&#039;s important
		 * that anything filtering this do the same. Use the helper methods in
		 * this class to map the fields as appropriate.
		 *
		 * Example:
		 *
		 *     add_filter( &#039;es_searchable_fields&#039;, function( $fields, $query ) {
		 *         // Add the post excerpt to the searchable fields.
		 *         $fields[] = $query-&gt;es_map( &#039;post_excerpt&#039; );
		 *         return $fields.
		 *     } );
		 *
		 * @see \ES_WP_Query_Wrapper::es_map() To map fields.
		 * @see \ES_WP_Query_Wrapper::tax_map() To map taxonomy fields.
		 * @see \ES_WP_Query_Wrapper::meta_map() To map meta fields.
		 *
		 * @param array $fields Mapped fields to search. It&#039;s extremely important
		 *                      that you map the fields before adding them to the
		 *                      array. See the example in this docblock.
		 * @param \ES_WP_Query $this This object. Passed to simplify field
		 *                           mapping.
		 */
		$fields = apply_filters( &#039;es_searchable_fields&#039;, $fields, $this );

		$search = array(
			&#039;multi_match&#039; =&gt; array(
				&#039;query&#039;    =&gt; $q[&#039;s&#039;],
				&#039;fields&#039;   =&gt; $fields,
				&#039;operator&#039; =&gt; &#039;and&#039;,
				&#039;type&#039;     =&gt; &#039;cross_fields&#039;,
			),
		);

		return $search;
	}

	/**
	 * If the passed orderby value is allowed, convert the alias to a
	 * properly-prefixed orderby value.
	 *
	 * @access protected
	 *
	 * @param string $orderby Alias for the field to order by.
	 * @return string|false Field to use in the sort clause. False otherwise.
	 */
	protected function parse_orderby( $orderby ) {
		// Meta values get special treatment.
		$meta_clauses       = $this-&gt;meta_query-&gt;queries;
		$meta_clauses_types = $this-&gt;meta_query-&gt;queries_types_all;

		if ( ! empty( $meta_clauses ) ) {
			if ( &#039;meta_value&#039; === $orderby ) {
				return $this-&gt;parse_orderby_for_meta( reset( $meta_clauses ) );
			} elseif ( &#039;meta_value_num&#039; === $orderby ) {
				return $this-&gt;parse_orderby_for_meta( reset( $meta_clauses ), &#039;double&#039; );
			} elseif ( array_key_exists( $orderby, $meta_clauses_types ) ) {
				return $this-&gt;parse_orderby_for_meta( $meta_clauses_types[ $orderby ] );
			}
		}

		if ( &#039;rand&#039; === $orderby ) {
			// @todo: implement `random_score`
			return false;
		}

		$field = parent::parse_orderby( $orderby );

		// We don&#039;t actually want the mysql column here, so we&#039;ll remove it.
		$field = preg_replace( &#039;/^.*\./&#039;, &#039;&#039;, $field );

		if ( &#039;ID&#039; === $field ) {
			return $this-&gt;es_map( &#039;post_id&#039; );
		} elseif ( ! preg_match( &#039;/[^a-z_]/i&#039;, $field ) ) {
			// Return it if the field only contains letters and underscores.
			return $this-&gt;es_map( $field );
		}

		return false;
	}

	/**
	 * Determine the orderby field for a meta clause.
	 *
	 * @param array  $clause A meta query clause.
	 * @param string $cast   Optional. What to cast the value as. Defaults to a match based on type.
	 * @access protected
	 * @return string|false Field to use in the sort clause. False otherwise.
	 */
	protected function parse_orderby_for_meta( $clause, $cast = &#039;&#039; ) {
		// Key is required for ordering.
		if ( empty( $clause[&#039;key&#039;] ) ) {
			return false;
		}

		if ( ! $cast ) {
			if ( ! empty( $clause[&#039;type&#039;] ) ) {
				$cast = $clause[&#039;type&#039;];
			}
			$cast = $this-&gt;meta_query-&gt;get_cast_for_type( $cast );
		}

		return $this-&gt;meta_map( $clause[&#039;key&#039;], $cast );
	}

	/**
	 * Parse an &#039;order&#039; query variable and cast it to asc or desc as necessary.
	 *
	 * @access protected
	 *
	 * @param string $order The &#039;order&#039; query variable.
	 * @return string The sanitized &#039;order&#039; query variable.
	 */
	protected function parse_order( $order ) {
		if ( ! is_string( $order ) || empty( $order ) ) {
			return &#039;desc&#039;;
		}

		if ( &#039;asc&#039; === strtolower( $order ) ) {
			return &#039;asc&#039;;
		} else {
			return &#039;desc&#039;;
		}
	}

	/**
	 * Convert MIME types into SQL.
	 *
	 * @param string|array $post_mime_types List of mime types or comma separated string of mime types.
	 * @access public
	 * @return string|array Array of filters and query on success, empty string on failure.
	 */
	public function post_mime_type_query( $post_mime_types ) {
		$wildcards         = array( &#039;&#039;, &#039;%&#039;, &#039;%/%&#039; );
		$strict_mime_types = array();
		$query             = array();
		$filters           = array();

		if ( is_string( $post_mime_types ) ) {
			$post_mime_types = array_map( &#039;trim&#039;, explode( &#039;,&#039;, $post_mime_types ) );
		}
		foreach ( (array) $post_mime_types as $mime_type ) {
			$mime_type = preg_replace( &#039;/\s/&#039;, &#039;&#039;, $mime_type );
			$slashpos  = strpos( $mime_type, &#039;/&#039; );
			if ( false !== $slashpos ) {
				$mime_group    = preg_replace( &#039;/[^-*.a-zA-Z0-9]/&#039;, &#039;&#039;, substr( $mime_type, 0, $slashpos ) );
				$mime_subgroup = preg_replace( &#039;/[^-*.+a-zA-Z0-9]/&#039;, &#039;&#039;, substr( $mime_type, $slashpos + 1 ) );
				if ( empty( $mime_subgroup ) ) {
					$mime_subgroup = &#039;*&#039;;
				} else {
					$mime_subgroup = str_replace( &#039;/&#039;, &#039;&#039;, $mime_subgroup );
				}
				$mime_pattern = &quot;$mime_group/$mime_subgroup&quot;;
			} else {
				$mime_pattern = preg_replace( &#039;/[^-*.a-zA-Z0-9]/&#039;, &#039;&#039;, $mime_type );
				if ( false === strpos( $mime_pattern, &#039;*&#039; ) ) {
					$mime_pattern .= &#039;/*&#039;;
				}
			}


			if ( in_array( $mime_type, $wildcards, true ) ) {
				return &#039;&#039;;
			}

			if ( false !== strpos( $mime_pattern, &#039;*&#039; ) ) {
				$mime_pattern = preg_replace( &#039;/\*+/&#039;, &#039;&#039;, $mime_pattern );
				$query[]      = array( &#039;prefix&#039; =&gt; array( $this-&gt;es_map( &#039;post_mime_type&#039; ) =&gt; $mime_pattern ) );
			} else {
				$strict_mime_types[] = $mime_pattern;
			}
		}

		if ( ! empty( $strict_mime_types ) ) {
			$filters = $this-&gt;dsl_terms( $this-&gt;es_map( &#039;post_mime_type&#039; ), $strict_mime_types );
		}

		return compact( &#039;filters&#039;, &#039;query&#039; );
	}

	/**
	 * Generates DSL for a term or terms query.
	 *
	 * @param string       $field  The field to query.
	 * @param string|array $values Term name or names to query against.
	 * @param array        $args   Additional arguments for the term(s) query.
	 * @access public
	 * @return array DSL for the term or terms query.
	 */
	public static function dsl_terms( $field, $values, $args = array() ) {
		$type = is_array( $values ) ? &#039;terms&#039; : &#039;term&#039;;
		return array( $type =&gt; array_merge( array( $field =&gt; $values ), $args ) );
	}

	/**
	 * Generates range DSL.
	 *
	 * @param string $field The field to query.
	 * @param array  $args  Range arguments for the field.
	 * @access public
	 * @return array DSL for the range query.
	 */
	public static function dsl_range( $field, $args ) {
		return array( &#039;range&#039; =&gt; array( $field =&gt; $args ) );
	}

	/**
	 * Generates exists DSL.
	 *
	 * @param string $field The field to query.
	 * @access public
	 * @return array DSL for the exists query.
	 */
	public static function dsl_exists( $field ) {
		return array( &#039;exists&#039; =&gt; array( &#039;field&#039; =&gt; $field ) );
	}

	/**
	 * Generates must not exist DSL.
	 *
	 * @param string $field The field to include.
	 * @param array  $args  Additional arguments for exists.
	 * @access public
	 * @return array DSL for the must not exist query.
	 */
	public static function dsl_missing( $field, $args = array() ) {
		return array(
			&#039;bool&#039; =&gt; array(
				&#039;must_not&#039; =&gt; array(
					&#039;exists&#039; =&gt; array_merge( array( &#039;field&#039; =&gt; $field ), $args ),
				),
			),
		);
	}

	/**
	 * Generates match DSL.
	 *
	 * @param string $field The field to include.
	 * @param mixed  $value The value to match against.
	 * @param array  $args  Additional arguments for match.
	 * @access public
	 * @return array DSL for the match query.
	 */
	public static function dsl_match( $field, $value, $args = array() ) {
		return array( &#039;match&#039; =&gt; array_merge( array( $field =&gt; $value ), $args ) );
	}

	/**
	 * Generates multi_match DSL.
	 *
	 * @param string|array $fields The fields to include.
	 * @param array        $query  The query to execute.
	 * @param array        $args   Additional arguments for multi_match.
	 * @access public
	 * @return array DSL for the multi_match query.
	 */
	public static function dsl_multi_match( $fields, $query, $args = array() ) {
		return array(
			&#039;multi_match&#039; =&gt; array_merge(
				array(
					&#039;query&#039;  =&gt; $query,
					&#039;fields&#039; =&gt; (array) $fields,
				),
				$args
			),
		);
	}

	/**
	 * Generates DSL for terms.
	 *
	 * @param string $field  The field key for the terms.
	 * @param array  $values The term names.
	 * @access public
	 * @return array DSL for the terms.
	 */
	public static function dsl_all_terms( $field, $values ) {
		$queries = array();
		foreach ( $values as $value ) {
			$queries[] = array( &#039;term&#039; =&gt; array( $field =&gt; $value ) );
		}
		return array( &#039;bool&#039; =&gt; array( &#039;filter&#039; =&gt; $queries ) );
	}
}
</code></pre>
            </article>
                <section data-search-results class="phpdocumentor-search-results phpdocumentor-search-results--hidden">
    <section class="phpdocumentor-search-results__dialog">
        <header class="phpdocumentor-search-results__header">
            <h2 class="phpdocumentor-search-results__title">Search results</h2>
            <button class="phpdocumentor-search-results__close"><i class="fas fa-times"></i></button>
        </header>
        <section class="phpdocumentor-search-results__body">
            <ul class="phpdocumentor-search-results__entries"></ul>
        </section>
    </section>
</section>
            </div>
        </div>
        <a href="files/search-es-wp-query-class-es-wp-query-wrapper.html#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <script>
        cssVars({});
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
