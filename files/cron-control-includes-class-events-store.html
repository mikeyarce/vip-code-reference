<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VIP Go mu-plugins</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../">
    <link rel="icon" href="images/favicon.ico"/>
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/base.css">
            <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/template.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.css">
            <script src="js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-header phpdocumentor-section">
    <h1 class="phpdocumentor-title"><a href="" class="phpdocumentor-title__link">VIP Go mu-plugins</a><span class="title-separator">/</span>mu-plugins</h1>
    <input class="phpdocumentor-header__menu-button" type="checkbox" id="menu-button" name="menu-button" />
    <label class="phpdocumentor-header__menu-icon" for="menu-button">
        <i class="fas fa-bars"></i>
    </label>
    <section data-search-form class="phpdocumentor-search">
    <label>
        <span class="visually-hidden">Search for</span>
        <svg class="phpdocumentor-search__icon" width="21" height="20" viewBox="0 0 21 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="7.5" cy="7.5" r="6.5" stroke="currentColor" stroke-width="2"/>
            <line x1="12.4892" y1="12.2727" x2="19.1559" y2="18.9393" stroke="currentColor" stroke-width="3"/>
        </svg>
        <input type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading .." disabled />
    </label>
</section>

    <nav class="phpdocumentor-topnav">
    <ul class="phpdocumentor-topnav__menu">
        </ul>
</nav>
</header>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <input class="phpdocumentor-sidebar__menu-button" type="checkbox" id="sidebar-button" name="sidebar-button" />
<label class="phpdocumentor-sidebar__menu-icon" for="sidebar-button">
    Menu
</label>
<aside class="phpdocumentor-column -four phpdocumentor-sidebar">
        
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
                                <h3 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/default.html"><abbr title="\">Global</abbr></a></h3>
                                        <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/automattic.html"><abbr title="\Automattic">Automattic</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/automattic-wp.html"><abbr title="\Automattic\WP">WP</abbr></a></li>
                                            <li><a href="namespaces/automattic-vip.html"><abbr title="\Automattic\VIP">VIP</abbr></a></li>
                                    </ul>
                            <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/tubalmartin.html"><abbr title="\tubalmartin">tubalmartin</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/tubalmartin-cssmin.html"><abbr title="\tubalmartin\CssMin">CssMin</abbr></a></li>
                                    </ul>
                        </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/VIP.html"><abbr title="\VIP">VIP</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/a8c.html"><abbr title="\a8c">a8c</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/a8c-Cron.html"><abbr title="\a8c\Cron">Cron</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/Http.html"><abbr title="\Http">Http</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/Http-Concat.html"><abbr title="\Http\Concat">Concat</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/ES.html"><abbr title="\ES">ES</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/ES-WP.html"><abbr title="\ES\WP">WP</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/wp.html"><abbr title="\wp">wp</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/wp-cli.html"><abbr title="\wp\cli">cli</abbr></a></li>
                            </ul>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="hooks/hooks.html">Hooks</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">class-events-store.php</h2>

            <p class="phpdocumentor-summary">Offload cron event storage to a custom table</p>

    <section class="phpdocumentor-description"></section>






<h3 id="interfaces_class_traits">
    Interfaces, Classes and Traits
    <a href="#interfaces_class_traits" class="headerlink"><i class="fas fa-link"></i></a>
</h3>

<dl class="phpdocumentor-table-of-contents">
    
            <dt class="phpdocumentor-table-of-contents__entry -class"><a href="classes/Automattic-WP-Cron-Control-Events-Store.html"><abbr title="\Automattic\WP\Cron_Control\Events_Store">Events_Store</abbr></a></dt>
        <dd>Events Store class</dd>
    
    </dl>





        

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * Offload cron event storage to a custom table
 *
 * @package a8c_Cron_Control
 */

namespace Automattic\WP\Cron_Control;

/**
 * Events Store class
 */
class Events_Store extends Singleton {
	/**
	 * PLUGIN SETUP
	 */

	/**
	 * Class constants
	 */
	const TABLE_SUFFIX = &#039;a8c_cron_control_jobs&#039;;

	const DB_VERSION        = 1;
	const DB_VERSION_OPTION = &#039;a8c_cron_control_db_version&#039;;
	const TABLE_CREATE_LOCK = &#039;a8c_cron_control_creating_table&#039;;

	const STATUS_PENDING   = &#039;pending&#039;;
	const STATUS_RUNNING   = &#039;running&#039;;
	const STATUS_COMPLETED = &#039;complete&#039;;
	const ALLOWED_STATUSES = array(
		self::STATUS_PENDING,
		self::STATUS_RUNNING,
		self::STATUS_COMPLETED,
	);

	const CACHE_KEY = &#039;a8c_cron_ctrl_option&#039;;

	/**
	 * Whether the static option cache is invalid
	 *
	 * @var bool
	 */
	private $is_option_cache_valid = false;

	/**
	 * Whether or not event creation is temporarily blocked
	 *
	 * @var bool
	 */
	private $job_creation_suspended = false;

	/**
	 * Register hooks
	 */
	protected function class_init() {
		// Create tables during installation.
		add_action( &#039;wp_install&#039;, array( $this, &#039;create_table_during_install&#039; ) );
		add_action( &#039;wpmu_new_blog&#039;, array( $this, &#039;create_tables_during_multisite_install&#039; ) );

		// Remove table when a multisite subsite is deleted.
		add_filter( &#039;wpmu_drop_tables&#039;, array( $this, &#039;remove_multisite_table&#039; ) );

		// Enable plugin when conditions support it, otherwise limit errors as much as possible.
		if ( self::is_installed() ) {
			// Option interception.
			add_filter( &#039;pre_option_cron&#039;, array( $this, &#039;get_option&#039; ) );
			add_filter( &#039;pre_update_option_cron&#039;, array( $this, &#039;update_option&#039; ), 10, 2 );

			// Disallow duplicates.
			add_filter( &#039;schedule_event&#039;, array( $this, &#039;block_creation_if_job_exists&#039; ) );
		} else {
			// Can&#039;t create events since there&#039;s no table to hold them.
			$this-&gt;suspend_event_creation();

			// Prime plugin&#039;s options when the options table exists.
			if ( ! defined( &#039;WP_INSTALLING&#039; ) || ! WP_INSTALLING ) {
				$this-&gt;prime_options();
			}

			// Don&#039;t schedule events that won&#039;t be run.
			add_filter( &#039;schedule_event&#039;, &#039;__return_false&#039; );

			// In limited circumstances, try creating the table.
			add_action( &#039;shutdown&#039;, array( $this, &#039;maybe_create_table_on_shutdown&#039; ) );
		}
	}

	/**
	 * Check if events store is ready
	 *
	 * Plugin breaks spectacularly if events store isn&#039;t available
	 *
	 * @return bool
	 */
	public static function is_installed() {
		$db_version = (int) get_option( self::DB_VERSION_OPTION );

		return version_compare( $db_version, 0, &#039;&gt;&#039; );
	}

	/**
	 * Build appropriate table name for this install
	 */
	public function get_table_name() {
		global $wpdb;

		return $wpdb-&gt;prefix . self::TABLE_SUFFIX;
	}

	/**
	 * Set initial options that control plugin&#039;s behaviour
	 */
	protected function prime_options() {
		// Prime DB option.
		add_option( self::DB_VERSION_OPTION, 0, null, false );
	}

	/**
	 * Create table during initial install
	 */
	public function create_table_during_install() {
		if ( &#039;wp_install&#039; !== current_action() ) {
			return;
		}

		$this-&gt;_prepare_table();
	}

	/**
	 * Create table when new subsite is added to a multisite
	 *
	 * @param int $bid Blog ID.
	 */
	public function create_tables_during_multisite_install( $bid ) {
		switch_to_blog( $bid );

		if ( ! self::is_installed() ) {
			$this-&gt;_prepare_table();
		}

		restore_current_blog();
	}

	/**
	 * For certain requests, create the table on shutdown
	 * Does not include front-end requests
	 */
	public function maybe_create_table_on_shutdown() {
		if ( ! is_admin() &amp;&amp; ! is_rest_endpoint_request( REST_API::ENDPOINT_LIST ) ) {
			return;
		}

		$this-&gt;prepare_table();
	}

	/**
	 * Create table in non-setup contexts, with some protections
	 */
	public function prepare_table() {
		// Table installed.
		if ( self::is_installed() ) {
			return;
		}

		// Nothing to do.
		$current_version = (int) get_option( self::DB_VERSION_OPTION );
		if ( version_compare( $current_version, self::DB_VERSION, &#039;&gt;=&#039; ) ) {
			return;
		}

		// Limit chance of race conditions when creating table.
		$create_lock_set = wp_cache_add( self::TABLE_CREATE_LOCK, 1, null, 1 * \MINUTE_IN_SECONDS );
		if ( false === $create_lock_set ) {
			return;
		}

		$this-&gt;_prepare_table();
	}

	/**
	 * Create the plugin&#039;s DB table when necessary
	 */
	protected function _prepare_table() {
		// Use Core&#039;s method of creating/updating tables.
		if ( ! function_exists( &#039;dbDelta&#039; ) ) {
			require_once ABSPATH . &#039;/wp-admin/includes/upgrade.php&#039;;
		}

		global $wpdb;

		$table_name = $this-&gt;get_table_name();

		// Define schema and create the table.
		$schema = &quot;CREATE TABLE `{$table_name}` (
			`ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,

			`timestamp` bigint(20) unsigned NOT NULL,
			`action` varchar(255) NOT NULL,
			`action_hashed` varchar(32) NOT NULL,
			`instance` varchar(32) NOT NULL,

			`args` longtext NOT NULL,
			`schedule` varchar(255) DEFAULT NULL,
			`interval` int unsigned DEFAULT 0,
			`status` varchar(32) NOT NULL DEFAULT &#039;pending&#039;,

			`created` datetime NOT NULL,
			`last_modified` datetime NOT NULL,

			PRIMARY KEY (`ID`),
			UNIQUE KEY `ts_action_instance_status` (`timestamp`, `action` (191), `instance`, `status`),
			KEY `status` (`status`)
		) ENGINE=InnoDB;\n&quot;;

		dbDelta( $schema, true );

		// Confirm that the table was created, and set the option to prevent further updates.
		$table_count = count( $wpdb-&gt;get_col( $wpdb-&gt;prepare( &#039;SHOW TABLES LIKE %s&#039;, $table_name ) ) );

		if ( 1 === $table_count ) {
			update_option( self::DB_VERSION_OPTION, self::DB_VERSION );
		}

		// Clear caches now that table exists.
		$this-&gt;flush_internal_caches();
	}

	/**
	 * Prepare table on demand via CLI
	 */
	public function cli_create_tables() {
		if ( ! defined( &#039;WP_CLI&#039; ) || ! \WP_CLI ) {
			return;
		}

		$this-&gt;_prepare_table();
	}

	/**
	 * When deleting a subsite from a multisite instance, include the plugin&#039;s table
	 *
	 * Core only drops its tables
	 *
	 * @param  array $tables_to_drop Array of prefixed table names to drop.
	 * @return array
	 */
	public function remove_multisite_table( $tables_to_drop ) {
		$tables_to_drop[] = $this-&gt;get_table_name();

		return $tables_to_drop;
	}

	/**
	 * PLUGIN FUNCTIONALITY
	 */

	/**
	 * Override cron option requests with data from custom table
	 */
	public function get_option() {

		// If this thread has already generated the cron array,
		// use the copy from local memory. Don&#039;t fetch this list
		// remotely multiple times per request (even from the
		// object cache).
		static $cron_array;
		if ( $cron_array &amp;&amp; true === $this-&gt;is_option_cache_valid ) {
			return $cron_array;
		}

		$this-&gt;is_option_cache_valid = true;

		// Use cached value when available.
		$cached_option = $this-&gt;get_cached_option();

		if ( false !== $cached_option ) {
			return $cached_option;
		}

		// Start building a new cron option.
		$cron_array = array(
			&#039;version&#039; =&gt; 2, // Core versions the cron array; without this, events will continually requeue.
		);

		// Get events to re-render as the cron option.
		$page     = 1;
		$quantity = 5000;

		do {
			$jobs = $this-&gt;get_jobs(
				array(
					&#039;status&#039;   =&gt; self::STATUS_PENDING,
					&#039;quantity&#039; =&gt; $quantity,
					&#039;page&#039;     =&gt; $page++,
				)
			);

			// Nothing more to add.
			if ( empty( $jobs ) ) {
				break;
			}

			// Loop through results and built output Core expects.
			foreach ( $jobs as $job ) {
				// Alias event timestamp.
				$timestamp = $job-&gt;timestamp;

				// If timestamp is invalid, event is removed to let its source fix it.
				if ( $timestamp &lt;= 0 ) {
					$this-&gt;mark_job_record_completed( $job-&gt;ID );
					continue;
				}

				// Basic arguments to add a job to the array format Core expects.
				$action   = $job-&gt;action;
				$instance = $job-&gt;instance;

				// Populate remaining job data.
				$cron_array[ $timestamp ][ $action ][ $instance ] = array(
					&#039;schedule&#039; =&gt; $job-&gt;schedule,
					&#039;args&#039;     =&gt; $job-&gt;args,
					&#039;interval&#039; =&gt; 0,
				);

				if ( isset( $job-&gt;interval ) ) {
					$cron_array[ $timestamp ][ $action ][ $instance ][&#039;interval&#039;] = $job-&gt;interval;
				}
			}
		} while ( count( $jobs ) &gt;= $quantity );

		// Re-sort the array just as Core does when events are scheduled.
		// Ensures events are sorted chronologically.
		uksort( $cron_array, &#039;strnatcasecmp&#039; );

		// Cache the results.
		$this-&gt;cache_option( $cron_array );

		return $cron_array;
	}

	/**
	 * Handle requests to update the cron option
	 *
	 * By returning $old_value, `cron` option won&#039;t be updated
	 *
	 * @param array $new_value New option value.
	 * @param array $old_value Old option value.
	 * @return array
	 */
	public function update_option( $new_value, $old_value ) {
		// Find changes to record.
		$new_events     = $this-&gt;find_cron_array_differences( $new_value, $old_value );
		$deleted_events = $this-&gt;find_cron_array_differences( $old_value, $new_value );

		// Add/update new events.
		foreach ( $new_events as $new_event ) {
			$job_id = $this-&gt;get_job_id( $new_event[&#039;timestamp&#039;], $new_event[&#039;action&#039;], $new_event[&#039;instance&#039;] );

			if ( 0 === $job_id ) {
				$job_id = null;
			}

			$this-&gt;create_or_update_job( $new_event[&#039;timestamp&#039;], $new_event[&#039;action&#039;], $new_event[&#039;args&#039;], $job_id, false );
		}

		// Mark deleted entries for removal.
		foreach ( $deleted_events as $deleted_event ) {
			$this-&gt;mark_job_completed( $deleted_event[&#039;timestamp&#039;], $deleted_event[&#039;action&#039;], $deleted_event[&#039;instance&#039;], false );
		}

		$this-&gt;flush_internal_caches();

		return $old_value;
	}

	/**
	 * When an entry exists, don&#039;t try to create it again
	 *
	 * @param object $job Job object.
	 * @return bool|object
	 */
	public function block_creation_if_job_exists( $job ) {
		// Job already disallowed, carry on.
		if ( ! is_object( $job ) ) {
			return $job;
		}

		$instance = md5( maybe_serialize( $job-&gt;args ) );
		if ( 0 !== $this-&gt;get_job_id( $job-&gt;timestamp, $job-&gt;hook, $instance ) ) {
			return false;
		}

		return $job;
	}

	/**
	 * PLUGIN UTILITY METHODS
	 */

	/**
	 * Retrieve jobs given a set of parameters
	 *
	 * @param array $args Job arguments to search by.
	 * @return array
	 */
	public function get_jobs( $args ) {
		global $wpdb;

		if ( ! isset( $args[&#039;quantity&#039;] ) || ! is_numeric( $args[&#039;quantity&#039;] ) ) {
			$args[&#039;quantity&#039;] = 100;
		}

		if ( isset( $args[&#039;page&#039;] ) ) {
			$page   = max( 0, $args[&#039;page&#039;] - 1 );
			$offset = $page * $args[&#039;quantity&#039;];
		} else {
			$offset = 0;
		}

		// Avoid sorting whenever possible, otherwise filesort is used.
		// Generally only necessary in CLI commands for pagination, as full list of events is usually required.
		if ( isset( $args[&#039;force_sort&#039;] ) &amp;&amp; true === $args[&#039;force_sort&#039;] ) {
			$query = $wpdb-&gt;prepare( &quot;SELECT * FROM {$this-&gt;get_table_name()} WHERE status = %s ORDER BY timestamp ASC LIMIT %d,%d;&quot;, $args[&#039;status&#039;], $offset, $args[&#039;quantity&#039;] ); // Cannot prepare table name. @codingStandardsIgnoreLine
		} else {
			$query = $wpdb-&gt;prepare( &quot;SELECT * FROM {$this-&gt;get_table_name()} WHERE status = %s LIMIT %d,%d;&quot;, $args[&#039;status&#039;], $offset, $args[&#039;quantity&#039;] ); // Cannot prepare table name. @codingStandardsIgnoreLine
		}

		$jobs = $wpdb-&gt;get_results( $query, &#039;OBJECT&#039; ); // Already prepared. @codingStandardsIgnoreLine

		if ( is_array( $jobs ) ) {
			$jobs = array_map( array( $this, &#039;format_job&#039; ), $jobs );
		} else {
			$jobs = array();
		}

		return $jobs;
	}

	/**
	 * Retrieve a single event by its ID
	 *
	 * @param int $jid Job ID.
	 * @return object|false
	 */
	public function get_job_by_id( $jid ) {
		global $wpdb;

		// Validate ID.
		$jid = absint( $jid );
		if ( ! $jid ) {
			return false;
		}

		$job = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT * FROM {$this-&gt;get_table_name()} WHERE ID = %d AND status = %s LIMIT 1&quot;, $jid, self::STATUS_PENDING ) ); // Cannot prepare table name. @codingStandardsIgnoreLine

		if ( is_object( $job ) &amp;&amp; ! is_wp_error( $job ) ) {
			$job = $this-&gt;format_job( $job );
		} else {
			$job = false;
		}

		return $job;
	}

	/**
	 * Retrieve a single event by a combination of its timestamp, instance identifier, and either action or the action&#039;s hashed representation
	 *
	 * @param array $attrs Array of event attributes to query by.
	 * @return object|false
	 */
	public function get_job_by_attributes( $attrs ) {
		global $wpdb;

		// Validate basic inputs.
		if ( ! is_array( $attrs ) || empty( $attrs ) ) {
			return false;
		}

		// Validate requested status.
		$allowed_status   = self::ALLOWED_STATUSES;
		$allowed_status[] = &#039;any&#039;;

		if ( ! isset( $attrs[&#039;status&#039;] ) || ! in_array( $attrs[&#039;status&#039;], $allowed_status, true ) ) {
			$attrs[&#039;status&#039;] = self::STATUS_PENDING;
		}

		// Need a timestamp, an instance, and either an action or its hashed representation.
		if ( ! isset( $attrs[&#039;timestamp&#039;] ) || ! isset( $attrs[&#039;instance&#039;] ) ) {
			return false;
		} elseif ( ! isset( $attrs[&#039;action&#039;] ) &amp;&amp; ! isset( $attrs[&#039;action_hashed&#039;] ) ) {
			return false;
		}

		// Build query.
		if ( isset( $attrs[&#039;action&#039;] ) ) {
			$action_column = &#039;action&#039;;
			$action_value  = $attrs[&#039;action&#039;];
		} else {
			$action_column = &#039;action_hashed&#039;;
			$action_value  = $attrs[&#039;action_hashed&#039;];
		}

		// Do not sort, otherwise index isn&#039;t used.
		if ( &#039;any&#039; === $attrs[&#039;status&#039;] ) {
			$query = $wpdb-&gt;prepare( &quot;SELECT * FROM {$this-&gt;get_table_name()} WHERE timestamp = %d AND {$action_column} = %s AND instance = %s LIMIT 1&quot;, $attrs[&#039;timestamp&#039;], $action_value, $attrs[&#039;instance&#039;] );  // Cannot prepare table or column names. @codingStandardsIgnoreLine
		} else {
			$query = $wpdb-&gt;prepare( &quot;SELECT * FROM {$this-&gt;get_table_name()} WHERE timestamp = %d AND {$action_column} = %s AND instance = %s AND status = %s LIMIT 1&quot;, $attrs[&#039;timestamp&#039;], $action_value, $attrs[&#039;instance&#039;], $attrs[&#039;status&#039;] );  // Cannot prepare table or column names. @codingStandardsIgnoreLine
		}

		// Query and format results.
		$job = $wpdb-&gt;get_row( $query ); // Already prepared. @codingStandardsIgnoreLine

		if ( is_object( $job ) &amp;&amp; ! is_wp_error( $job ) ) {
			$job = $this-&gt;format_job( $job );
		} else {
			$job = false;
		}

		return $job;
	}

	/**
	 * Get ID for given event details
	 *
	 * Used in situations where performance matters, which is why it exists despite duplicating `get_job_by_attributes()`
	 * Queries outside of this class should use `get_job_by_attributes()`
	 *
	 * @param int    $timestamp    Unix timestamp event executes at.
	 * @param string $action       Name of action used when the event is registered (unhashed).
	 * @param string $instance     md5 hash of the event&#039;s arguments array, which Core uses to index the `cron` option.
	 * @return int
	 */
	private function get_job_id( $timestamp, $action, $instance ) {
		global $wpdb;

		$job = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT ID FROM {$this-&gt;get_table_name()} WHERE timestamp = %d AND action = %s AND instance = %s AND status = %s LIMIT 1;&quot;, $timestamp, $action, $instance, self::STATUS_PENDING ) ); // Cannot prepare table name. @codingStandardsIgnoreLine

		return empty( $job ) ? 0 : (int) array_shift( $job );
	}

	/**
	 * Standardize formatting and expand serialized data
	 *
	 * @param object $job Job row from DB, in object form.
	 * @return object
	 */
	private function format_job( $job ) {
		if ( ! is_object( $job ) || is_wp_error( $job ) ) {
			return $job;
		}

		$job-&gt;ID        = (int) $job-&gt;ID;
		$job-&gt;timestamp = (int) $job-&gt;timestamp;
		$job-&gt;interval  = (int) $job-&gt;interval;
		$job-&gt;args      = maybe_unserialize( $job-&gt;args );

		if ( empty( $job-&gt;schedule ) ) {
			$job-&gt;schedule = false;
		}

		return $job;
	}

	/**
	 * Create or update entry for a given job
	 *
	 * @param int    $timestamp    Unix timestamp event executes at.
	 * @param string $action       Hook event fires.
	 * @param array  $args         Array of event&#039;s schedule, arguments, and interval.
	 * @param bool   $update_id    ID of existing entry to update, rather than creating a new entry.
	 * @param bool   $flush_cache  Whether or not to flush internal caches after creating/updating the event.
	 */
	public function create_or_update_job( $timestamp, $action, $args, $update_id = null, $flush_cache = true ) {
		// Don&#039;t create new jobs when manipulating jobs via the plugin&#039;s CLI commands.
		if ( $this-&gt;job_creation_suspended ) {
			return;
		}

		global $wpdb;

		$job_post = array(
			&#039;timestamp&#039;     =&gt; $timestamp,
			&#039;action&#039;        =&gt; $action,
			&#039;action_hashed&#039; =&gt; md5( $action ),
			&#039;instance&#039;      =&gt; md5( maybe_serialize( $args[&#039;args&#039;] ) ),
			&#039;args&#039;          =&gt; maybe_serialize( $args[&#039;args&#039;] ),
			&#039;last_modified&#039; =&gt; current_time( &#039;mysql&#039;, true ),
		);

		if ( isset( $args[&#039;schedule&#039;] ) &amp;&amp; ! empty( $args[&#039;schedule&#039;] ) ) {
			$job_post[&#039;schedule&#039;] = $args[&#039;schedule&#039;];
		}

		if ( isset( $args[&#039;interval&#039;] ) &amp;&amp; ! empty( $args[&#039;interval&#039;] ) &amp;&amp; is_numeric( $args[&#039;interval&#039;] ) ) {
			$job_post[&#039;interval&#039;] = (int) $args[&#039;interval&#039;];
		}

		// Create the post, or update an existing entry to run again in the future.
		if ( is_int( $update_id ) &amp;&amp; $update_id &gt; 0 ) {
			$wpdb-&gt;update(
				$this-&gt;get_table_name(),
				$job_post,
				array(
					&#039;ID&#039; =&gt; $update_id,
				)
			);
		} else {
			$job_post[&#039;created&#039;] = current_time( &#039;mysql&#039;, true );

			$wpdb-&gt;insert( $this-&gt;get_table_name(), $job_post );
		}

		// Delete internal cache.
		// Should only be skipped during bulk operations.
		if ( $flush_cache ) {
			$this-&gt;flush_internal_caches();
		}
	}

	/**
	 * Mark an event&#039;s entry as completed
	 *
	 * Completed entries will be cleaned up by an internal job
	 *
	 * @param int    $timestamp    Unix timestamp event executes at.
	 * @param string $action       Name of action used when the event is registered (unhashed).
	 * @param string $instance     md5 hash of the event&#039;s arguments array, which Core uses to index the `cron` option.
	 * @param bool   $flush_cache  Whether or not to flush internal caches after creating/updating the event.
	 * @return bool
	 */
	public function mark_job_completed( $timestamp, $action, $instance, $flush_cache = true ) {
		$job_id = $this-&gt;get_job_id( $timestamp, $action, $instance );

		if ( ! $job_id ) {
			return false;
		}

		return $this-&gt;mark_job_record_completed( $job_id, $flush_cache );
	}

	/**
	 * Set a job post to the &quot;completed&quot; status
	 *
	 * @param int  $job_id       ID of job&#039;s record.
	 * @param bool $flush_cache  Whether or not to flush internal caches after creating/updating the event.
	 * @return bool
	 */
	public function mark_job_record_completed( $job_id, $flush_cache = true ) {
		global $wpdb;

		/**
		 * Constraint is broken to accommodate the following situation:
		 * 1. Event with specific timestamp is scheduled.
		 * 2. Event is unscheduled.
		 * 3. Event is rescheduled.
		 * 4. Event runs, or is unscheduled, but unique constraint prevents query from succeeding.
		 * 5. Event retains `pending` status and runs again. Repeat steps 4 and 5 until `a8c_cron_control_purge_completed_events` runs and removes the entry from step 2.
		 */
		$updates = array(
			&#039;status&#039;   =&gt; self::STATUS_COMPLETED,
			&#039;instance&#039; =&gt; mt_rand( 1000000, 999999999 ), // Breaks unique constraint, and can be recreated from entry&#039;s remaining data.
		);

		$success = $wpdb-&gt;update(
			$this-&gt;get_table_name(),
			$updates,
			array(
				&#039;ID&#039; =&gt; $job_id,
			)
		);

		// Delete internal cache.
		// Should only be skipped during bulk operations.
		if ( $flush_cache ) {
			$this-&gt;flush_internal_caches();
		}

		return (bool) $success;
	}

	/**
	 * Compare two arrays and return collapsed representation of the items present in one but not the other
	 *
	 * @param array $changed   Array to identify additional items from.
	 * @param array $reference Array to compare against.
	 * @return array
	 */
	private function find_cron_array_differences( $changed, $reference ) {
		$differences = array();

		$changed = collapse_events_array( $changed );

		foreach ( $changed as $event ) {
			$event = (object) $event;

			if ( ! isset( $reference[ $event-&gt;timestamp ][ $event-&gt;action ][ $event-&gt;instance ] ) ) {
				$differences[] = array(
					&#039;timestamp&#039; =&gt; $event-&gt;timestamp,
					&#039;action&#039;    =&gt; $event-&gt;action,
					&#039;instance&#039;  =&gt; $event-&gt;instance,
					&#039;args&#039;      =&gt; $event-&gt;args,
				);
			}
		}

		return $differences;
	}

	/**
	 * Retrieve cron option from cache
	 *
	 * @return array|false
	 */
	private function get_cached_option() {
		$cache_details = wp_cache_get( self::CACHE_KEY, null, true );

		if ( ! is_array( $cache_details ) ) {
			return false;
		}

		// Single bucket.
		if ( isset( $cache_details[&#039;version&#039;] ) ) {
			return $cache_details;
		}

		// Invalid data!
		if ( ! isset( $cache_details[&#039;incrementer&#039;] ) ) {
			return false;
		}

		$option_flat = array();

		// Restore option from cached pieces.
		for ( $i = 1; $i &lt;= $cache_details[&#039;buckets&#039;]; $i++ ) {
			$cache_key    = $this-&gt;get_cache_key_for_slice( $cache_details[&#039;incrementer&#039;], $i );
			$cached_slice = wp_cache_get( $cache_key, null, true );

			// Bail if a chunk is missing.
			if ( ! is_array( $cached_slice ) ) {
				return false;
			}

			$option_flat += $cached_slice;
		}

		// Something&#039;s missing, likely due to cache eviction.
		if ( empty( $option_flat ) || count( $option_flat ) !== $cache_details[&#039;event_count&#039;] ) {
			return false;
		}

		return inflate_collapsed_events_array( $option_flat );
	}

	/**
	 * Cache cron option, accommodating large versions by splitting into chunks
	 *
	 * @param array $option Cron option to cache.
	 * @return bool
	 */
	private function cache_option( $option ) {
		// Determine storage requirements.
		$option_flat        = collapse_events_array( $option );
		$option_flat_string = maybe_serialize( $option_flat );
		$option_size        = strlen( $option_flat_string );
		$buckets            = (int) ceil( $option_size / CACHE_BUCKET_SIZE );

		// Store in single cache key.
		if ( 1 === $buckets ) {
			return wp_cache_set( self::CACHE_KEY, $option, null, 1 * \HOUR_IN_SECONDS );
		}

		// Too large to cache?
		if ( $buckets &gt; MAX_CACHE_BUCKETS ) {
			do_action( &#039;a8c_cron_control_uncacheable_cron_option&#039;, $option_size, $buckets, count( $option_flat ) );

			$this-&gt;flush_internal_caches();
			return false;
		}

		$incrementer  = md5( $option_flat_string . time() );
		$event_count  = count( $option_flat );
		$segment_size = (int) ceil( $event_count / $buckets );

		for ( $i = 1; $i &lt;= $buckets; $i++ ) {
			$offset    = ( $i - 1 ) * $segment_size;
			$slice     = array_slice( $option_flat, $offset, $segment_size );
			$cache_key = $this-&gt;get_cache_key_for_slice( $incrementer, $i );

			wp_cache_set( $cache_key, $slice, null, 1 * \HOUR_IN_SECONDS );
		}

		$option = array(
			&#039;incrementer&#039; =&gt; $incrementer,
			&#039;buckets&#039;     =&gt; $buckets,
			&#039;event_count&#039; =&gt; count( $option_flat ),
		);

		return wp_cache_set( self::CACHE_KEY, $option, null, 1 * \HOUR_IN_SECONDS );
	}

	/**
	 * Build cache key for a given portion of a large option
	 *
	 * @param string $incrementor Current cache incrementor.
	 * @param int    $slice Slice ID.
	 * @return string
	 */
	private function get_cache_key_for_slice( $incrementor, $slice ) {
		return md5( self::CACHE_KEY . $incrementor . $slice );
	}

	/**
	 * Delete the cached representation of the cron option
	 */
	public function flush_internal_caches() {
		$this-&gt;is_option_cache_valid = false;
		return wp_cache_delete( self::CACHE_KEY );
	}

	/**
	 * Prevent event store from creating new entries
	 *
	 * Should be used sparingly, and followed by a call to resume_event_creation(), during bulk operations
	 */
	public function suspend_event_creation() {
		$this-&gt;job_creation_suspended = true;
	}

	/**
	 * Stop discarding events, once again storing them in the table
	 */
	public function resume_event_creation() {
		$this-&gt;job_creation_suspended = false;
	}

	/**
	 * Remove entries for non-recurring events that have been run
	 *
	 * @param bool $count_first Should events be counted before they&#039;re deleted.
	 */
	public function purge_completed_events( $count_first = true ) {
		global $wpdb;

		// Skip count if already performed.
		if ( $count_first ) {
			if ( property_exists( $wpdb, &#039;srtm&#039; ) ) {
				$srtm       = $wpdb-&gt;srtm;
				$wpdb-&gt;srtm = true;
			}

			$count = $this-&gt;count_events_by_status( self::STATUS_COMPLETED );

			if ( isset( $srtm ) ) {
				$wpdb-&gt;srtm = $srtm;
			}
		} else {
			$count = 1;
		}

		if ( $count &gt; 0 ) {
			$wpdb-&gt;delete(
				$this-&gt;get_table_name(),
				array(
					&#039;status&#039; =&gt; self::STATUS_COMPLETED,
				)
			);
		}
	}

	/**
	 * Count number of events with a given status
	 *
	 * @param string $status Event status to count.
	 * @return int|false
	 */
	public function count_events_by_status( $status ) {
		global $wpdb;

		if ( ! in_array( $status, self::ALLOWED_STATUSES, true ) ) {
			return false;
		}

		return (int) $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(ID) FROM {$this-&gt;get_table_name()} WHERE status = %s&quot;, $status ) ); // Cannot prepare table name. @codingStandardsIgnoreLine
	}
}

Events_Store::instance();
</code></pre>
            </article>
                <section data-search-results class="phpdocumentor-search-results phpdocumentor-search-results--hidden">
    <section class="phpdocumentor-search-results__dialog">
        <header class="phpdocumentor-search-results__header">
            <h2 class="phpdocumentor-search-results__title">Search results</h2>
            <button class="phpdocumentor-search-results__close"><i class="fas fa-times"></i></button>
        </header>
        <section class="phpdocumentor-search-results__body">
            <ul class="phpdocumentor-search-results__entries"></ul>
        </section>
    </section>
</section>
            </div>
        </div>
        <a href="files/cron-control-includes-class-events-store.html#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <script>
        cssVars({});
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
