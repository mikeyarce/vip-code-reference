<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VIP Go mu-plugins</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../">
    <link rel="icon" href="images/favicon.ico"/>
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/base.css">
            <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/template.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.css">
            <script src="js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-header phpdocumentor-section">
    <h1 class="phpdocumentor-title"><a href="" class="phpdocumentor-title__link">VIP Go mu-plugins</a><span class="title-separator">/</span>mu-plugins</h1>
    <input class="phpdocumentor-header__menu-button" type="checkbox" id="menu-button" name="menu-button" />
    <label class="phpdocumentor-header__menu-icon" for="menu-button">
        <i class="fas fa-bars"></i>
    </label>
    <section data-search-form class="phpdocumentor-search">
    <label>
        <span class="visually-hidden">Search for</span>
        <svg class="phpdocumentor-search__icon" width="21" height="20" viewBox="0 0 21 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="7.5" cy="7.5" r="6.5" stroke="currentColor" stroke-width="2"/>
            <line x1="12.4892" y1="12.2727" x2="19.1559" y2="18.9393" stroke="currentColor" stroke-width="3"/>
        </svg>
        <input type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading .." disabled />
    </label>
</section>

    <nav class="phpdocumentor-topnav">
    <ul class="phpdocumentor-topnav__menu">
        </ul>
</nav>
</header>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <input class="phpdocumentor-sidebar__menu-button" type="checkbox" id="sidebar-button" name="sidebar-button" />
<label class="phpdocumentor-sidebar__menu-icon" for="sidebar-button">
    Menu
</label>
<aside class="phpdocumentor-column -four phpdocumentor-sidebar">
        
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
                                <h3 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/default.html"><abbr title="\">Global</abbr></a></h3>
                                        <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/automattic.html"><abbr title="\Automattic">Automattic</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/automattic-wp.html"><abbr title="\Automattic\WP">WP</abbr></a></li>
                                            <li><a href="namespaces/automattic-vip.html"><abbr title="\Automattic\VIP">VIP</abbr></a></li>
                                    </ul>
                            <h4 class="phpdocumentor-sidebar__root-namespace"><a href="namespaces/tubalmartin.html"><abbr title="\tubalmartin">tubalmartin</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="namespaces/tubalmartin-cssmin.html"><abbr title="\tubalmartin\CssMin">CssMin</abbr></a></li>
                                    </ul>
                        </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/VIP.html"><abbr title="\VIP">VIP</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/a8c.html"><abbr title="\a8c">a8c</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/a8c-Cron.html"><abbr title="\a8c\Cron">Cron</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/Http.html"><abbr title="\Http">Http</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/Http-Concat.html"><abbr title="\Http\Concat">Concat</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/ES.html"><abbr title="\ES">ES</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/ES-WP.html"><abbr title="\ES\WP">WP</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="packages/wp.html"><abbr title="\wp">wp</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="packages/wp-cli.html"><abbr title="\wp\cli">cli</abbr></a></li>
                            </ul>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="hooks/hooks.html">Hooks</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">class-events.php</h2>

            <p class="phpdocumentor-summary">Manage event execution</p>

    <section class="phpdocumentor-description"></section>






<h3 id="interfaces_class_traits">
    Interfaces, Classes and Traits
    <a href="#interfaces_class_traits" class="headerlink"><i class="fas fa-link"></i></a>
</h3>

<dl class="phpdocumentor-table-of-contents">
    
            <dt class="phpdocumentor-table-of-contents__entry -class"><a href="classes/Automattic-WP-Cron-Control-Events.html"><abbr title="\Automattic\WP\Cron_Control\Events">Events</abbr></a></dt>
        <dd>Events class</dd>
    
    </dl>





        

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * Manage event execution
 *
 * @package a8c_Cron_Control
 */

namespace Automattic\WP\Cron_Control;

/**
 * Events class
 */
class Events extends Singleton {
	/**
	 * PLUGIN SETUP
	 */

	/**
	 * Class constants
	 */
	const LOCK = &#039;run-events&#039;;

	const DISABLE_RUN_OPTION = &#039;a8c_cron_control_disable_run&#039;;

	/**
	 * List of actions whitelisted for concurrent execution
	 *
	 * @var array
	 */
	private $concurrent_action_whitelist = array();

	/**
	 * Name of action currently being executed
	 *
	 * @var mixed
	 */
	private $running_event = null;

	/**
	 * Register hooks
	 */
	protected function class_init() {
		// Prime lock cache if not present.
		Lock::prime_lock( self::LOCK );

		// Prepare environment as early as possible.
		$earliest_action = did_action( &#039;muplugins_loaded&#039; ) ? &#039;plugins_loaded&#039; : &#039;muplugins_loaded&#039;;
		add_action( $earliest_action, array( $this, &#039;prepare_environment&#039; ) );

		// Allow code loaded as late as the theme to modify the whitelist.
		add_action( &#039;after_setup_theme&#039;, array( $this, &#039;populate_concurrent_action_whitelist&#039; ) );
	}

	/**
	 * Prepare environment to run job
	 *
	 * Must run as early as possible, particularly before any client code is loaded
	 * This also runs before Core has parsed the request and set the \REST_REQUEST constant
	 */
	public function prepare_environment() {
		// Limit to plugin&#039;s endpoints.
		$endpoint = get_endpoint_type();
		if ( false === $endpoint ) {
			return;
		}

		// Flag is used in many contexts, so should be set for all of our requests, regardless of the action.
		set_doing_cron();

		// When running events, allow for long-running ones, and non-blocking trigger requests.
		if ( REST_API::ENDPOINT_RUN === $endpoint ) {
			ignore_user_abort( true );
			set_time_limit( JOB_TIMEOUT_IN_MINUTES * MINUTE_IN_SECONDS );
		}
	}

	/**
	 * Allow certain events to be run concurrently
	 *
	 * By default, multiple events of the same action cannot be run concurrently, due to alloptions and other data-corruption issues
	 * Some events, however, are fine to run concurrently, and should be whitelisted for such
	 */
	public function populate_concurrent_action_whitelist() {
		$concurrency_whitelist = apply_filters( &#039;a8c_cron_control_concurrent_event_whitelist&#039;, array() );

		if ( is_array( $concurrency_whitelist ) &amp;&amp; ! empty( $concurrency_whitelist ) ) {
			$this-&gt;concurrent_action_whitelist = $concurrency_whitelist;
		}
	}

	/**
	 * List events pending for the current period
	 */
	public function get_events() {
		$events = get_option( &#039;cron&#039; );

		// That was easy.
		if ( ! is_array( $events ) || empty( $events ) ) {
			return array(
				&#039;events&#039; =&gt; null,
			);
		}

		// Simplify array format for further processing.
		$events = collapse_events_array( $events );

		// Select only those events to run in the next sixty seconds.
		// Will include missed events as well.
		$current_events  = array();
		$internal_events = array();
		$current_window  = strtotime( sprintf( &#039;+%d seconds&#039;, JOB_QUEUE_WINDOW_IN_SECONDS ) );

		foreach ( $events as $event ) {
			// Skip events whose time hasn&#039;t come.
			if ( $event[&#039;timestamp&#039;] &gt; $current_window ) {
				continue;
			}

			// Skip events that don&#039;t have any callbacks hooked to their actions, unless their execution is requested.
			if ( ! $this-&gt;action_has_callback_or_should_run_anyway( $event ) ) {
				continue;
			}

			// Necessary data to identify an individual event.
			// `$event[&#039;action&#039;]` is hashed to avoid information disclosure.
			// Core hashes `$event[&#039;instance&#039;]` for us.
			$event_data_public = array(
				&#039;timestamp&#039; =&gt; $event[&#039;timestamp&#039;],
				&#039;action&#039;    =&gt; md5( $event[&#039;action&#039;] ),
				&#039;instance&#039;  =&gt; $event[&#039;instance&#039;],
			);

			// Queue internal events separately to avoid them being blocked.
			if ( is_internal_event( $event[&#039;action&#039;] ) ) {
				$internal_events[] = $event_data_public;
			} else {
				$current_events[] = $event_data_public;
			}
		}

		// Limit batch size to avoid resource exhaustion.
		if ( count( $current_events ) &gt; JOB_QUEUE_SIZE ) {
			$current_events = $this-&gt;reduce_queue( $current_events );
		}

		// Combine with Internal Events.
		// TODO: un-nest array, which is nested for legacy reasons.
		return array(
			&#039;events&#039; =&gt; array_merge( $current_events, $internal_events ),
		);
	}

	/**
	 * Check that an event has a callback to run, and allow the check to be overridden
	 * Empty events are, by default, skipped and removed/rescheduled
	 *
	 * @param array $event Event data.
	 * @return bool
	 */
	private function action_has_callback_or_should_run_anyway( $event ) {
		// Event has a callback, so let&#039;s get on with it.
		if ( false !== has_action( $event[&#039;action&#039;] ) ) {
			return true;
		}

		// Run the event anyway, perhaps because callbacks are added using the `all` action.
		if ( apply_filters( &#039;a8c_cron_control_run_event_with_no_callbacks&#039;, false, $event ) ) {
			return true;
		}

		// Remove or reschedule the empty event.
		if ( false === $event[&#039;args&#039;][&#039;schedule&#039;] ) {
			wp_unschedule_event( $event[&#039;timestamp&#039;], $event[&#039;action&#039;], $event[&#039;args&#039;][&#039;args&#039;] );
		} else {
			$timestamp = $event[&#039;timestamp&#039;] + ( isset( $event[&#039;args&#039;][&#039;interval&#039;] ) ? $event[&#039;args&#039;][&#039;interval&#039;] : 0 );
			wp_reschedule_event( $timestamp, $event[&#039;args&#039;][&#039;schedule&#039;], $event[&#039;action&#039;], $event[&#039;args&#039;][&#039;args&#039;] );
			unset( $timestamp );
		}

		return false;
	}

	/**
	 * Trim events queue down to the limit set by JOB_QUEUE_SIZE
	 *
	 * @param array $events List of events to be run in the current period.
	 *
	 * @return array
	 */
	private function reduce_queue( $events ) {
		// Loop through events, adding one of each action during each iteration.
		$reduced_queue = array();
		$action_counts = array();

		$i = 1; // Intentionally not zero-indexed to facilitate comparisons against $action_counts members.

		do {
			// Each time the events array is iterated over, move one instance of an action to the current queue.
			foreach ( $events as $key =&gt; $event ) {
				$action = $event[&#039;action&#039;];

				// Prime the count.
				if ( ! isset( $action_counts[ $action ] ) ) {
					$action_counts[ $action ] = 0;
				}

				// Check and do the move.
				if ( $action_counts[ $action ] &lt; $i ) {
					$reduced_queue[] = $event;
					$action_counts[ $action ]++;
					unset( $events[ $key ] );
				}
			}

			// When done with an iteration and events remain, start again from the beginning of the $events array.
			if ( empty( $events ) ) {
				break;
			} else {
				$i++;
				reset( $events );

				continue;
			}
		} while ( $i &lt;= 15 &amp;&amp; count( $reduced_queue ) &lt; JOB_QUEUE_SIZE &amp;&amp; ! empty( $events ) );

		/**
		 * IMPORTANT: DO NOT re-sort the $reduced_queue array from this point forward.
		 * Doing so defeats the preceding effort.
		 *
		 * While the events are now out of order with respect to timestamp, they&#039;re ordered
		 * such that one of each action is run before another of an already-run action.
		 * The timestamp mis-ordering is trivial given that we&#039;re only dealing with events
		 * for the current JOB_QUEUE_WINDOW_IN_SECONDS.
		 */

		// Finally, ensure that we don&#039;t have more than we need.
		if ( count( $reduced_queue ) &gt; JOB_QUEUE_SIZE ) {
			$reduced_queue = array_slice( $reduced_queue, 0, JOB_QUEUE_SIZE );
		}

		return $reduced_queue;
	}

	/**
	 * Execute a specific event
	 *
	 * @param int    $timestamp Unix timestamp.
	 * @param string $action md5 hash of the action used when the event is registered.
	 * @param string $instance  md5 hash of the event&#039;s arguments array, which Core uses to index the `cron` option.
	 * @param bool   $force Run event regardless of timestamp or lock status? eg, when executing jobs via wp-cli.
	 * @return array|\WP_Error
	 */
	public function run_event( $timestamp, $action, $instance, $force = false ) {
		// Validate input data.
		if ( empty( $timestamp ) || empty( $action ) || empty( $instance ) ) {
			return new \WP_Error(
				&#039;missing-data&#039;,
				__( &#039;Invalid or incomplete request data.&#039;, &#039;automattic-cron-control&#039; ),
				array(
					&#039;status&#039; =&gt; 400,
				)
			);
		}

		// Ensure we don&#039;t run jobs ahead of time.
		if ( ! $force &amp;&amp; $timestamp &gt; time() ) {
			return new \WP_Error(
				&#039;premature&#039;,
				/* translators: 1: Job identifier */
				sprintf( __( &#039;Job with identifier `%1$s` is not scheduled to run yet.&#039;, &#039;automattic-cron-control&#039; ), &quot;$timestamp-$action-$instance&quot; ),
				array(
					&#039;status&#039; =&gt; 403,
				)
			);
		}

		// Find the event to retrieve the full arguments.
		$event = get_event_by_attributes(
			array(
				&#039;timestamp&#039;     =&gt; $timestamp,
				&#039;action_hashed&#039; =&gt; $action,
				&#039;instance&#039;      =&gt; $instance,
				&#039;status&#039;        =&gt; Events_Store::STATUS_PENDING,
			)
		);

		// Nothing to do...
		if ( ! is_object( $event ) ) {
			return new \WP_Error(
				&#039;no-event&#039;,
				/* translators: 1: Job identifier */
				sprintf( __( &#039;Job with identifier `%1$s` could not be found.&#039;, &#039;automattic-cron-control&#039; ), &quot;$timestamp-$action-$instance&quot; ),
				array(
					&#039;status&#039; =&gt; 404,
				)
			);
		}

		unset( $timestamp, $action, $instance );

		// Limit how many events are processed concurrently, unless explicitly bypassed.
		if ( ! $force ) {
			// Prepare event-level lock.
			$this-&gt;prime_event_action_lock( $event );

			if ( ! $this-&gt;can_run_event( $event ) ) {
				return new \WP_Error(
					&#039;no-free-threads&#039;,
					/* translators: 1: Event action, 2: Event arguments */
					sprintf( __( &#039;No resources available to run the job with action `%1$s` and arguments `%2$s`.&#039;, &#039;automattic-cron-control&#039; ), $event-&gt;action, maybe_serialize( $event-&gt;args ) ),
					array(
						&#039;status&#039; =&gt; 429,
					)
				);
			}

			// Free locks should event throw uncatchable error.
			$this-&gt;running_event = $event;
			add_action( &#039;shutdown&#039;, array( $this, &#039;do_lock_cleanup_on_shutdown&#039; ) );
		}

		// Mark the event completed, and reschedule if desired.
		// Core does this before running the job, so we respect that.
		$this-&gt;update_event_record( $event );

		// Run the event.
		try {
			do_action_ref_array( $event-&gt;action, $event-&gt;args );
		} catch ( \Throwable $t ) {
			/**
			 * Note that timeouts and memory exhaustion do not invoke this block.
			 * Instead, those locks are freed in `do_lock_cleanup_on_shutdown()`.
			 */

			do_action( &#039;a8c_cron_control_event_threw_catchable_error&#039;, $event, $t );

			$return = array(
				&#039;success&#039; =&gt; false,
				/* translators: 1: Event action, 2: Event arguments, 3: Throwable error, 4: Line number that raised Throwable error */
				&#039;message&#039; =&gt; sprintf( __( &#039;Callback for job with action `%1$s` and arguments `%2$s` raised a Throwable - %3$s in %4$s on line %5$d.&#039;, &#039;automattic-cron-control&#039; ), $event-&gt;action, maybe_serialize( $event-&gt;args ), $t-&gt;getMessage(), $t-&gt;getFile(), $t-&gt;getLine() ),
			);
		}

		// Free locks for the next event, unless they weren&#039;t set to begin with.
		if ( ! $force ) {
			// If we got this far, there&#039;s no uncaught error to handle.
			$this-&gt;running_event = null;
			remove_action( &#039;shutdown&#039;, array( $this, &#039;do_lock_cleanup_on_shutdown&#039; ) );

			$this-&gt;do_lock_cleanup( $event );
		}

		// Callback didn&#039;t trigger a Throwable, indicating it succeeded.
		if ( ! isset( $return ) ) {
			$return = array(
				&#039;success&#039; =&gt; true,
				/* translators: 1: Event action, 2: Event arguments */
				&#039;message&#039; =&gt; sprintf( __( &#039;Job with action `%1$s` and arguments `%2$s` executed.&#039;, &#039;automattic-cron-control&#039; ), $event-&gt;action, maybe_serialize( $event-&gt;args ) ),
			);
		}

		return $return;
	}

	/**
	 * Prime the event-specific lock
	 *
	 * Used to ensure only one instance of a particular event, such as `wp_version_check` runs at one time
	 *
	 * @param object $event Event data.
	 */
	private function prime_event_action_lock( $event ) {
		Lock::prime_lock( $this-&gt;get_lock_key_for_event_action( $event ), JOB_LOCK_EXPIRY_IN_MINUTES * \MINUTE_IN_SECONDS );
	}

	/**
	 * Are resources available to run this event?
	 *
	 * @param object $event Event data.
	 * @return bool
	 */
	private function can_run_event( $event ) {
		// Limit to one concurrent execution of a specific action by default.
		$limit = 1;

		if ( isset( $this-&gt;concurrent_action_whitelist[ $event-&gt;action ] ) ) {
			$limit = absint( $this-&gt;concurrent_action_whitelist[ $event-&gt;action ] );
			$limit = min( $limit, JOB_CONCURRENCY_LIMIT );
		}

		if ( ! Lock::check_lock( $this-&gt;get_lock_key_for_event_action( $event ), $limit, JOB_LOCK_EXPIRY_IN_MINUTES * \MINUTE_IN_SECONDS ) ) {
			return false;
		}

		// Internal Events aren&#039;t subject to the global lock.
		if ( is_internal_event( $event-&gt;action ) ) {
			return true;
		}

		// Check if any resources are available to execute this job.
		// If not, the individual-event lock must be freed, otherwise it&#039;s deadlocked until it times out.
		if ( ! Lock::check_lock( self::LOCK, JOB_CONCURRENCY_LIMIT ) ) {
			$this-&gt;reset_event_lock( $event );
			return false;
		}

		// Let&#039;s go!
		return true;
	}

	/**
	 * Free locks after event completes
	 *
	 * @param object $event Event data.
	 */
	private function do_lock_cleanup( $event ) {
		// Lock isn&#039;t set when event is Internal, so we don&#039;t want to alter it.
		if ( ! is_internal_event( $event-&gt;action ) ) {
			Lock::free_lock( self::LOCK );
		}

		// Reset individual event lock.
		$this-&gt;reset_event_lock( $event );
	}

	/**
	 * Frees the lock for an individual event
	 *
	 * @param object $event Event data.
	 * @return bool
	 */
	private function reset_event_lock( $event ) {
		$lock_key = $this-&gt;get_lock_key_for_event_action( $event );
		$expires  = JOB_LOCK_EXPIRY_IN_MINUTES * \MINUTE_IN_SECONDS;

		if ( isset( $this-&gt;concurrent_action_whitelist[ $event-&gt;action ] ) ) {
			return Lock::free_lock( $lock_key, $expires );
		} else {
			return Lock::reset_lock( $lock_key, $expires );
		}
	}

	/**
	 * Turn the event action into a string that can be used with a lock
	 *
	 * @param object $event Event data.
	 * @return string
	 */
	public function get_lock_key_for_event_action( $event ) {
		// Hashed solely to constrain overall length.
		return md5( &#039;ev-&#039; . $event-&gt;action );
	}

	/**
	 * Mark an event completed, and reschedule when requested
	 *
	 * @param object $event Event data.
	 */
	private function update_event_record( $event ) {
		if ( false !== $event-&gt;schedule ) {
			// Re-implements much of the logic from `wp_reschedule_event()`.
			$schedules = wp_get_schedules();
			$interval  = 0;

			// First, we try to get it from the schedule.
			if ( isset( $schedules[ $event-&gt;schedule ] ) ) {
				$interval = (int) $schedules[ $event-&gt;schedule ][&#039;interval&#039;];
			}

			// Now we try to get it from the saved interval, in case the schedule disappears.
			if ( 0 === $interval ) {
				$interval = $event-&gt;interval;
			}

			// If we have an interval, update the existing event entry.
			if ( 0 !== $interval ) {
				// Determine new timestamp, according to how `wp_reschedule_event()` does.
				$now           = time();
				$new_timestamp = $event-&gt;timestamp;

				if ( $new_timestamp &gt;= $now ) {
					$new_timestamp = $now + $interval;
				} else {
					$new_timestamp = $now + ( $interval - ( ( $now - $new_timestamp ) % $interval ) );
				}

				// Build the expected arguments format.
				$event_args = array(
					&#039;schedule&#039; =&gt; $event-&gt;schedule,
					&#039;args&#039;     =&gt; $event-&gt;args,
					&#039;interval&#039; =&gt; $interval,
				);

				// Update event store.
				schedule_event( $new_timestamp, $event-&gt;action, $event_args, $event-&gt;ID );

				// If the event could be rescheduled, don&#039;t then delete it.
				return;
			}
		}

		// Either event doesn&#039;t recur, or the interval couldn&#039;t be determined.
		delete_event( $event-&gt;timestamp, $event-&gt;action, $event-&gt;instance );
	}

	/**
	 * If event execution throws uncatchable error, free locks
	 *
	 * Covers situations such as timeouts and memory exhaustion, which aren&#039;t \Throwable errors
	 *
	 * Under normal conditions, this callback isn&#039;t hooked to `shutdown`
	 */
	public function do_lock_cleanup_on_shutdown() {
		if ( is_null( $this-&gt;running_event ) ) {
			return;
		}

		do_action( &#039;a8c_cron_control_freeing_event_locks_after_uncaught_error&#039;, $this-&gt;running_event );

		$this-&gt;do_lock_cleanup( $this-&gt;running_event );
	}

	/**
	 * Return status of automatic event execution
	 *
	 * @return int 0 if run is enabled, 1 if run is disabled indefinitely, otherwise timestamp when execution will resume
	 */
	public function run_disabled() {
		$disabled = (int) get_option( self::DISABLE_RUN_OPTION, 0 );

		if ( $disabled &lt;= 1 || $disabled &gt; time() ) {
			return $disabled;
		}

		$this-&gt;update_run_status( 0 );
		return 0;
	}

	/**
	 * Set automatic execution status
	 *
	 * @param int $new_status 0 if run is enabled, 1 if run is disabled indefinitely, otherwise timestamp when execution will resume.
	 * @return bool
	 */
	public function update_run_status( $new_status ) {
		$new_status = absint( $new_status );

		// Don&#039;t store a past timestamp.
		if ( $new_status &gt; 1 &amp;&amp; $new_status &lt; time() ) {
			return false;
		}

		return update_option( self::DISABLE_RUN_OPTION, $new_status );
	}
}

Events::instance();
</code></pre>
            </article>
                <section data-search-results class="phpdocumentor-search-results phpdocumentor-search-results--hidden">
    <section class="phpdocumentor-search-results__dialog">
        <header class="phpdocumentor-search-results__header">
            <h2 class="phpdocumentor-search-results__title">Search results</h2>
            <button class="phpdocumentor-search-results__close"><i class="fas fa-times"></i></button>
        </header>
        <section class="phpdocumentor-search-results__body">
            <ul class="phpdocumentor-search-results__entries"></ul>
        </section>
    </section>
</section>
            </div>
        </div>
        <a href="files/cron-control-includes-class-events.html#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <script>
        cssVars({});
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
